<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>SPA - Control por Vista (Touch Look) - F√≠sica Avanzada</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a0a0a">
<style>
html,body{margin:0;overflow:hidden;height:100%;background:#000}
#renderCanvas{width:100%;height:100%}
.button{position:absolute;bottom:30px;width:80px;height:80px;background:rgba(255,255,255,0.25);border-radius:50%;pointer-events:auto;}
#btnForward{right:40px}
#btnBackward{right:140px}
#speedBarContainer{position:absolute;top:10px;left:100px;width:200px;height:20px;background:#444;border:1px solid #fff}
#speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
#debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
#joystickContainer { position: absolute; bottom: 30px; left: 50px; width: 160px; height: 120px; pointer-events: auto; z-index: 10; }
#joystickBase { position: absolute; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); }
#joystickHandle { position: absolute; width: 50px; height: 100px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s; }
#joystickAxis { position: absolute; width: 100%; height: 1px; background: rgba(255, 255, 255, 0.2); top: 50%; left: 0; transform: translateY(-50%); }
.joystick-disabled { opacity: 0.5; pointer-events: none; }
#timerPanel { position: absolute; top: 60px; left: 10 ; width: 140px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 5px; color: #fff; font-family: monospace; z-index: 10; font-size: 12px;}
#currentTimer { font-size: 18px; text-align: center; margin-bottom: 5px; color: #0f0; }
#lapTimes { font-size: 10px; max-height: 100px; overflow-y: auto; }
.lap-time { padding: 1px 0; border-bottom: 1px solid #444; }
.lap-time:last-child { border-bottom: none; }
.best-lap { color: #ff0; font-weight: bold; }
#timerStatus { text-align: center; font-size: 12px; margin-top: 2px; color: #0ff; }
#bestLapDisplay { text-align: center; font-size: 12px; margin-top: 2px; color: #ff0; }

/* Bot√≥n pantalla completa */
#fullscreenBtn{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    padding:15px 25px;
    font-size:20px;
    background:rgba(0,0,0,0.7);
    color:#0f0;
    border:2px solid #0f0;
    border-radius:10px;
    z-index:100;
}

/* Botones configuraci√≥n y coches */
#settingsBtn, #carsBtn {
    position:absolute;
    top:5px;
    width:50px;
    height:50px;
    background:rgba(255,255,255,0.25);
    border-radius:50%;
    font-size:28px;
    text-align:center;
    line-height:50px;
    cursor:pointer;
    z-index:100;
}
#settingsBtn{ right:70px; }
#carsBtn{ right:10px; font-size:24px; }

/* Paneles */
.settings-panel{
    position:absolute;
    top:60px;
    right:10px;
    width:240px;
    background:rgba(0,0,0,0.95);
    border:2px solid #fff;
    border-radius:10px;
    padding:15px;
    color:#fff;
    font-family:monospace;
    display:none;
    z-index:101;
    max-height:80vh;
    overflow-y:auto;
}
.settings-panel label{display:block;margin:8px 0 4px;font-size:14px;}
.settings-panel input[type=range]{width:100%;margin:5px 0;}
.settings-panel select, .settings-panel input[type=number]{width:100%;margin-bottom:8px;padding:4px;}
.settings-panel button{width:100%;padding:8px;margin-top:8px;}

/* Estilos espec√≠ficos para el panel de coches */
.car-option {
    padding: 10px;
    margin: 5px 0;
    background: rgba(255,255,255,0.1);
    border-radius: 5px;
    cursor: pointer;
    border: 1px solid transparent;
}
.car-option:hover {
    background: rgba(255,255,255,0.2);
    border-color: #0f0;
}
.car-option.selected {
    background: rgba(0,255,0,0.2);
    border-color: #0f0;
}
.car-stats {
    font-size: 12px;
    color: #ccc;
    margin-top: 5px;
}

/* Bot√≥n posici√≥n inicial */
#resetPositionBtn{
    position:absolute;
    top:5px;
    left:10px;
    width:40px;
    height:40px;
    background:rgba(255,255,255,0.25);
    border-radius:50%;
    pointer-events:auto;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:24px;
    color:white;
}

/* Indicador de calibraci√≥n de giroscopio */
#gyroIndicator {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 20px;
    background: rgba(0,0,0,0.7);
    border: 1px solid #fff;
    border-radius: 10px;
    display: none;
    z-index: 10;
}

#gyroIndicatorBar {
    height: 100%;
    width: 50%;
    background: #0f0;
    border-radius: 10px;
    transition: width 0.1s;
}

/* Indicador de orientaci√≥n */
#orientationInfo {
    position: absolute;
    top: 35px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    font-family: monospace;
    display: none;
    z-index: 10;
}

/* Sliders tipo volumen (acelerador/freno) - MEJORADOS */
.slider {
    position: absolute;
    bottom: 30px;
    width: 80px;
    height: 200px;
    background: rgba(255,255,255,0.06);
    border-radius: 20px;
    border: 2px solid rgba(255,255,255,0.08);
    touch-action: none;
    z-index: 20;
    display: flex;
    align-items: flex-end;
    overflow: hidden;
}
#throttleSlider{ right: 30px; }
#brakeSlider{ right: 130px; left: auto; }
.slider-fill {
    width: 100%;
    height: 0%;
    background: linear-gradient(180deg, rgba(0,255,0,0.25), rgba(0,255,0,0.6));
    border-radius: 16px 16px 6px 6px;
    transition: height 0.05s;
}
#brakeFill {
    background: linear-gradient(180deg, rgba(255,0,0,0.25), rgba(255,0,0,0.6));
}
.slider-label{position:absolute;top:-22px;right:0;font-size:12px;color:#fff;font-family:monospace}

/* Indicadores num√©ricos peque√±os */
.pedal-value{
    position:absolute;
    bottom:240px;
    right:30px;
    color:#fff;
    font-family:monospace;
    font-size:12px;
    z-index:21;
}
.pedal-value.brake{ right:130px; left: auto; }

/* Indicador de marcha */
#gearIndicator {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
    font-family: monospace;
    z-index: 10;
    border: 1px solid #fff;
}
/* Indicador de velocidad num√©rico */
#speedNumber {
    position: absolute;
    bottom: 50px; /* Justo arriba del indicador de marchas */
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #0f0;
    padding: 5px 15px;
    border-radius: 5px;
    font-size: 18px;
    font-family: monospace;
    z-index: 10;
    border: 1px solid #0f0;
    font-weight: bold;
}
    /* Controles de cambio de marchas */
#gearControls {
    position: absolute;
    bottom: 250px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    align-items: center;
    z-index: 25;
}

.gear-btn {
    width: 60px;
    height: 60px;
    background: rgba(255,255,255,0.2);
    border: 2px solid #fff;
    border-radius: 50%;
    color: #fff;
    font-size: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s;
}

.gear-btn:active {
    background: rgba(255,255,255,0.4);
    transform: scale(0.95);
}

#gearModeBtn {
    width: 120px;
    height: 40px;
    border-radius: 20px;
    font-size: 14px;
    background: rgba(0,255,0,0.3);
    border: 2px solid #0f0;
}

#gearModeBtn.manual {
    background: rgba(255,255,0,0.3);
    border-color: #ff0;
}

</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito...</div>
<div id="resetPositionBtn" title="Posici√≥n Inicial">üèÅ</div>
<div id="gearIndicator">N</div>
<div id="speedNumber">0 km/h</div>
<div id="gearControls">
    <div class="gear-btn" id="gearDown">-</div>
    <div class="gear-btn" id="gearModeBtn">AUTO</div>
    <div class="gear-btn" id="gearUp">+</div>
</div>
<!-- Indicador de calibraci√≥n de giroscopio -->
<div id="gyroIndicator">
    <div id="gyroIndicatorBar"></div>
</div>

<!-- Informaci√≥n de orientaci√≥n -->
<div id="orientationInfo"></div>

<!-- Joystick -->
<div id="joystickContainer" class="joystick-disabled">
  <div id="joystickBase">
    <div id="joystickAxis"></div>
    <div id="joystickHandle"></div>
  </div>
</div>

<!-- Sliders tipo volumen para acelerador y freno - MEJORADOS -->
<div id="throttleSlider" class="slider" aria-label="Acelerador">
    <div id="throttleFill" class="slider-fill"></div>
    <div class="slider-label">Acel</div>
</div>
<div id="brakeSlider" class="slider" aria-label="Freno">
    <div id="brakeFill" class="slider-fill"></div>
    <div class="slider-label">Freno</div>
</div>
<div class="pedal-value" id="throttleValue">0%</div>
<div class="pedal-value brake" id="brakeValue">0%</div>

<div id="timerPanel">
  <div id="currentTimer">00:00.000</div>
  <div id="lapTimes"></div>
  <div id="timerStatus">ESPERANDO EN META</div>
  <div id="bestLapDisplay">MEJOR VUELTA: --:--.---</div>
</div>

<!-- Botones -->
<button id="fullscreenBtn">Pantalla Completa</button>
<div id="settingsBtn">‚öôÔ∏è</div>
<div id="carsBtn">üöó</div>

<!-- Panel de Configuraci√≥n -->
<div id="settingsPanel" class="settings-panel">
    <label>Velocidad M√°x: <span id="maxSpeedLabel">330</span> km/h</label>
    <input type="range" id="maxSpeedRange" min="50" max="500" value="330">
    
    <label>Aceleraci√≥n 0-100: <span id="accelLabel">2.0</span>s</label>
    <input type="range" id="accelRange" min="1.5" max="6.0" step="0.1" value="2.0">

    <label>Freno: <span id="brakeLabel">150</span></label>
    <input type="range" id="brakeRange" min="20" max="300" value="150">

    <label>Altura de C√°mara: <span id="cameraHeightLabel">3.0</span> m</label>
    <input type="range" id="cameraHeightRange" min="1.0" max="6.0" step="0.1" value="3.0">

    <!-- Nuevos controles para giroscopio -->
    <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
        <label style="display: flex; align-items: center; justify-content: space-between;">
            <span>Control por Giroscopio</span>
            <input type="checkbox" id="gyroToggle" style="width: auto;">
        </label>
        
        <div id="gyroControls" style="display: none;">
            <label>Sensibilidad: <span id="gyroSensitivityLabel">1.0</span></label>
            <input type="range" id="gyroSensitivityRange" min="0.1" max="8.0" step="0.1" value="1.0">
            
            <label>M√°ximo Giro: <span id="gyroMaxLabel">2.0</span></label>
            <input type="range" id="gyroMaxRange" min="0.5" max="8.0" step="0.1" value="2.0">
            
            <label>Modo de Control</label>
            <select id="gyroModeSelect">
                <option value="beta">Inclinaci√≥n Frontal (Beta)</option>
                <option value="gamma">Inclinaci√≥n Lateral (Gamma)</option>
                <option value="auto">Autom√°tico (Recomendado)</option>
            </select>
            
            <button id="calibrateGyroBtn">Calibrar Giroscopio</button>
            <div style="font-size: 12px; margin-top: 5px; color: #ccc;">
                <div>Gira el dispositivo como un volante</div>
                <div id="gyroStatus">Estado: No disponible</div>
                <div id="gyroDebug" style="font-size: 10px; margin-top: 3px;"></div>
            </div>
        </div>
    </div>

    <label>Clima</label>
    <select id="weatherSelect">
        <option value="sunny">Soleado</option>
        <option value="gray">Cielo Gris</option>
        <option value="sunset">Atardecer Azul</option>
    </select>

    <label>M√∫sica</label>
    <button id="musicBtn">On</button>

    <label>N√∫mero de Vueltas</label>
    <input type="number" id="lapsNumber" min="1" max="99" value="3">
</div>

<!-- Panel de Selecci√≥n de Coches -->
<div id="carsPanel" class="settings-panel">
    <h3 style="text-align:center;margin-top:0;">SELECCIONAR COCHE</h3>
    
    <div class="car-option selected" data-car="f1">
        <strong>F√≥rmula 1</strong>
        <div class="car-stats">Vel: 350 km/h | 0-100: 1.8s | Peso: 740kg | Downforce: Alto</div>
    </div>
    
    <div class="car-option" data-car="gt3">
        <strong>GT3</strong>
        <div class="car-stats">Vel: 300 km/h | 0-100: 2.5s | Peso: 1250kg | Downforce: Medio</div>
    </div>
    
    <div class="car-option" data-car="gt4">
        <strong>GT4</strong>
        <div class="car-stats">Vel: 250 km/h | 0-100: 3.2s | Peso: 1350kg | Downforce: Bajo</div>
    </div>
    
    <div class="car-option" data-car="hypercar">
        <strong>Hypercar</strong>
        <div class="car-stats">Vel: 400 km/h | 0-100: 2.2s | Peso: 1100kg | Downforce: Muy Alto</div>
    </div>
    
    <div class="car-option" data-car="touring">
        <strong>Touring Car</strong>
        <div class="car-stats">Vel: 280 km/h | 0-100: 3.5s | Peso: 1150kg | Downforce: Muy Bajo</div>
    </div>
    
    <div class="car-option" data-car="rally">
        <strong>Rally</strong>
        <div class="car-stats">Vel: 220 km/h | 0-100: 4.0s | Peso: 1300kg | Downforce: M√≠nimo</div>
    </div>
    
    <div class="car-option" data-car="drift">
        <strong>Drift Car</strong>
        <div class="car-stats">Vel: 240 km/h | 0-100: 3.8s | Peso: 1200kg | Downforce: M√≠nimo</div>
    </div>
</div>

<audio id="motorAudio" src="motor.mp3" loop></audio>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// =========================
// Fullscreen
// =========================
const fullscreenBtn = document.getElementById("fullscreenBtn");
fullscreenBtn.addEventListener('click', () => {
    document.documentElement.requestFullscreen?.().catch(() => {});
    if (screen.orientation && screen.orientation.lock) screen.orientation.lock("landscape").catch(() => {});
    fullscreenBtn.style.display = 'none';
});

// =========================
// Configuraci√≥n
// =========================
const settingsBtn = document.getElementById("settingsBtn");
const carsBtn = document.getElementById("carsBtn");
const settingsPanel = document.getElementById("settingsPanel");
const carsPanel = document.getElementById("carsPanel");

settingsBtn.addEventListener('click', () => { 
    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    carsPanel.style.display = 'none';
});

carsBtn.addEventListener('click', () => { 
    carsPanel.style.display = carsPanel.style.display === 'none' ? 'block' : 'none';
    settingsPanel.style.display = 'none';
});

// Controles
const maxSpeedRange = document.getElementById("maxSpeedRange");
const accelRange = document.getElementById("accelRange");
const brakeRange = document.getElementById("brakeRange");
const cameraHeightRange = document.getElementById("cameraHeightRange");
const maxSpeedLabel = document.getElementById("maxSpeedLabel");
const accelLabel = document.getElementById("accelLabel");
const brakeLabel = document.getElementById("brakeLabel");
const cameraHeightLabel = document.getElementById("cameraHeightLabel");

// Variables del juego
let maxSpeed = 330;
let targetAccelerationTime = 2.0;
let brakeFriction = 150;
let cameraHeight = 3.0;
let currentCar = 'f1'; // Coches por defecto

// =========================
// F√çSICA AVANZADA - SISTEMA COMPLETO
// =========================

// Base de datos de coches MEJORADA con propiedades f√≠sicas
const cars = {
    'f1': { 
        name: 'F√≥rmula 1', 
        maxSpeed: 350, 
        acceleration: 1.8, 
        brake: 180,
        weight: 740,        // kg
        downforce: 1.8,     // coeficiente de carga aerodin√°mica
        drag: 0.75,         // coeficiente de resistencia aerodin√°mica
        centerOfMass: 0.4,  // posici√≥n del centro de masa (0-1, m√°s bajo = m√°s estable)
        tireGrip: 1.4       // agarre de neum√°ticos
    },
    'gt3': { 
        name: 'GT3', 
        maxSpeed: 300, 
        acceleration: 2.5, 
        brake: 160,
        weight: 1250,
        downforce: 1.2,
        drag: 0.85,
        centerOfMass: 0.45,
        tireGrip: 1.2
    },
    'gt4': { 
        name: 'GT4', 
        maxSpeed: 250, 
        acceleration: 3.2, 
        brake: 140,
        weight: 1350,
        downforce: 0.9,
        drag: 0.95,
        centerOfMass: 0.5,
        tireGrip: 1.1
    },
    'hypercar': { 
        name: 'Hypercar', 
        maxSpeed: 400, 
        acceleration: 2.2, 
        brake: 200,
        weight: 1100,
        downforce: 1.6,
        drag: 0.65,
        centerOfMass: 0.42,
        tireGrip: 1.35
    },
    'touring': { 
        name: 'Touring Car', 
        maxSpeed: 280, 
        acceleration: 3.5, 
        brake: 130,
        weight: 1150,
        downforce: 0.7,
        drag: 1.05,
        centerOfMass: 0.52,
        tireGrip: 1.0
    },
    'rally': { 
        name: 'Rally', 
        maxSpeed: 220, 
        acceleration: 4.0, 
        brake: 120,
        weight: 1300,
        downforce: 0.5,
        drag: 1.15,
        centerOfMass: 0.55,
        tireGrip: 0.9
    },
    'drift': { 
        name: 'Drift Car', 
        maxSpeed: 240, 
        acceleration: 3.8, 
        brake: 110,
        weight: 1200,
        downforce: 0.4,
        drag: 1.1,
        centerOfMass: 0.48,
        tireGrip: 0.8
    }
};

// Variables de f√≠sica avanzada
let carWeight = 740;
let carDownforce = 1.8;
let carDrag = 0.75;
let carCenterOfMass = 0.4;
let carTireGrip = 1.4;
let lateralGForce = 0;
let currentDownforce = 0;
let suspensionTravel = 0;
let isBraking = false;
let isAccelerating = false;

// Fuerzas f√≠sicas
const GRAVITY = 9.81; // m/s¬≤
const AIR_DENSITY = 1.225; // kg/m¬≥
const FRONTAL_AREA = 2.0; // m¬≤ (√°rea frontal promedio de un coche)

// Funci√≥n para calcular aceleraci√≥n
function calculateAccelerationFromTime(zeroTo100Time) {
    const targetSpeedMs = 27.78; // 100 km/h en m/s
    return (targetSpeedMs / zeroTo100Time) * 3;
}

let accel = calculateAccelerationFromTime(targetAccelerationTime);

// Funci√≥n para cambiar de coche
function changeCar(carType) {
    const car = cars[carType];
    if (!car) return;
    
    currentCar = carType;
    
    // Actualizar valores
    maxSpeed = car.maxSpeed;
    targetAccelerationTime = car.acceleration;
    brakeFriction = car.brake;
    accel = calculateAccelerationFromTime(targetAccelerationTime);
    
    // Actualizar propiedades f√≠sicas
    carWeight = car.weight;
    carDownforce = car.downforce;
    carDrag = car.drag;
    carCenterOfMass = car.centerOfMass;
    carTireGrip = car.tireGrip;
    
    // Actualizar UI
    maxSpeedRange.value = maxSpeed;
    maxSpeedLabel.textContent = maxSpeed;
    
    accelRange.value = targetAccelerationTime;
    accelLabel.textContent = targetAccelerationTime.toFixed(1);
    
    brakeRange.value = brakeFriction;
    brakeLabel.textContent = brakeFriction;
    
    // Actualizar selecci√≥n visual
    document.querySelectorAll('.car-option').forEach(option => {
        option.classList.remove('selected');
    });
    document.querySelector(`.car-option[data-car="${carType}"]`).classList.add('selected');
    
    debug.textContent = `Coche cambiado a: ${car.name} | Peso: ${carWeight}kg`;
}

// Event listeners para selecci√≥n de coches
document.querySelectorAll('.car-option').forEach(option => {
    option.addEventListener('click', () => {
        const carType = option.getAttribute('data-car');
        changeCar(carType);
        carsPanel.style.display = 'none';
    });
});

// Event listeners para los controles
maxSpeedRange.addEventListener('input', () => { 
    maxSpeed = parseInt(maxSpeedRange.value); 
    maxSpeedLabel.textContent = maxSpeed; 
});

accelRange.addEventListener('input', () => { 
    targetAccelerationTime = parseFloat(accelRange.value);
    accel = calculateAccelerationFromTime(targetAccelerationTime);
    accelLabel.textContent = targetAccelerationTime.toFixed(1);
});

brakeRange.addEventListener('input', () => { 
    brakeFriction = parseInt(brakeRange.value); 
    brakeLabel.textContent = brakeFriction; 
});

cameraHeightRange.addEventListener('input', () => { 
    cameraHeight = parseFloat(cameraHeightRange.value);
    cameraHeightLabel.textContent = cameraHeight.toFixed(1);
    if (camera) {
        camera.position.y = cameraHeight;
    }
});

// Clima
const weatherSelect = document.getElementById("weatherSelect");

// M√∫sica
const musicBtn = document.getElementById("musicBtn");
const motorAudio = document.getElementById("motorAudio");
let musicOn = true;
musicBtn.addEventListener('click', () => {
    musicOn = !musicOn;
    if (musicOn) motorAudio.play();
    else motorAudio.pause();
    musicBtn.textContent = musicOn ? "On" : "Off";
});

// N√∫mero de vueltas
const lapsNumberInput = document.getElementById("lapsNumber");
let totalLaps = parseInt(lapsNumberInput.value);
lapsNumberInput.addEventListener('input', () => { totalLaps = parseInt(lapsNumberInput.value); });

// =========================
// GIROSCOPIO - VERSI√ìN CORREGIDA PARA HORIZONTAL
// =========================
const gyroToggle = document.getElementById("gyroToggle");
const gyroControls = document.getElementById("gyroControls");
const calibrateGyroBtn = document.getElementById("calibrateGyroBtn");
const gyroStatus = document.getElementById("gyroStatus");
const gyroDebug = document.getElementById("gyroDebug");
const gyroIndicator = document.getElementById("gyroIndicator");
const gyroIndicatorBar = document.getElementById("gyroIndicatorBar");
const gyroSensitivityRange = document.getElementById("gyroSensitivityRange");
const gyroMaxRange = document.getElementById("gyroMaxRange");
const gyroSensitivityLabel = document.getElementById("gyroSensitivityLabel");
const gyroMaxLabel = document.getElementById("gyroMaxLabel");
const gyroModeSelect = document.getElementById("gyroModeSelect");
const orientationInfo = document.getElementById("orientationInfo");

let gyroEnabled = false;
let gyroCalibrated = false;
let gyroCalibrationValue = 0;
let gyroRotation = 0;
let gyroAvailable = false;
let gyroSensitivity = 1.0;
let gyroMaxRotation = 1.0;
let currentGyroMode = 'auto';

// Configuraci√≥n de sensibilidad
gyroSensitivityRange.addEventListener('input', () => {
    gyroSensitivity = parseFloat(gyroSensitivityRange.value);
    gyroSensitivityLabel.textContent = gyroSensitivity.toFixed(1);
});

gyroMaxRange.addEventListener('input', () => {
    gyroMaxRotation = parseFloat(gyroMaxRange.value);
    gyroMaxLabel.textContent = gyroMaxRotation.toFixed(1);
});

gyroModeSelect.addEventListener('change', () => {
    currentGyroMode = gyroModeSelect.value;
});

// Verificar si el giroscopio est√° disponible
if (window.DeviceOrientationEvent) {
    gyroAvailable = true;
    gyroStatus.textContent = "Estado: Disponible";
} else {
    gyroStatus.textContent = "Estado: No compatible";
}

// Referencia al joystick para ocultarlo cuando se use giroscopio
const joystickContainer = document.getElementById("joystickContainer");

// Evento para activar/desactivar el giroscopio
gyroToggle.addEventListener('change', () => {
    gyroEnabled = gyroToggle.checked;
    
    if (gyroEnabled) {
        // OCULTAR JOYSTICK CUANDO EL GIROSCOPIO EST√Å ACTIVADO
        joystickContainer.style.display = 'none';
        
        // MOVER FRENO A LA IZQUIERDA EN MODO GIROSCOPIO
        document.getElementById('brakeSlider').style.left = '30px';
        document.getElementById('brakeSlider').style.right = 'auto';
        document.querySelector('.pedal-value.brake').style.left = '30px';
        document.querySelector('.pedal-value.brake').style.right = 'auto';

        gyroControls.style.display = 'block';
        gyroIndicator.style.display = 'block';
        orientationInfo.style.display = 'block';
        
        // Solicitar permiso para el giroscopio (necesario en iOS)
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                        gyroStatus.textContent = "Estado: Activado";
                    } else {
                        gyroStatus.textContent = "Estado: Permiso denegado";
                        gyroToggle.checked = false;
                        gyroEnabled = false;
                        joystickContainer.style.display = 'block';
                        // RESTAURAR POSICI√ìN ORIGINAL DEL FRENO
                        resetBrakePosition();
                    }
                })
                .catch(err => {
                    console.error(err);
                    gyroToggle.checked = false;
                    gyroEnabled = false;
                    joystickContainer.style.display = 'block';
                    // RESTAURAR POSICI√ìN ORIGINAL DEL FRENO
                    resetBrakePosition();
                });
        } else {
            window.addEventListener('deviceorientation', handleDeviceOrientation);
            gyroStatus.textContent = "Estado: Activado";
        }
    } else {
        // MOSTRAR JOYSTICK CUANDO EL GIROSCOPIO EST√Å APAGADO
        joystickContainer.style.display = 'block';
        
        // RESTAURAR POSICI√ìN ORIGINAL DEL FRENO
        resetBrakePosition();

        gyroControls.style.display = 'none';
        gyroIndicator.style.display = 'none';
        orientationInfo.style.display = 'none';
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
        gyroStatus.textContent = "Estado: Desactivado";
  
      gyroRotation = 0;
    }
});

// Funci√≥n para restaurar la posici√≥n original del freno
function resetBrakePosition() {
    const brakeSlider = document.getElementById('brakeSlider');
    const brakeValue = document.querySelector('.pedal-value.brake');
    
    brakeSlider.style.left = 'auto';
    brakeSlider.style.right = '130px';
    brakeValue.style.left = 'auto';
    brakeValue.style.right = '130px';
}

// Funci√≥n para determinar el eje correcto seg√∫n la orientaci√≥n
function getSteeringAxis(event) {
    const beta = event.beta;  // Inclinaci√≥n frontal (-180 a 180)
    const gamma = event.gamma; // Inclinaci√≥n lateral (-90 a 90)
    
    let steeringValue;
    
    if (currentGyroMode === 'beta') {
        steeringValue = beta;
    } else if (currentGyroMode === 'gamma') {
        steeringValue = gamma;
    } else {
        const absBeta = Math.abs(beta);
        const absGamma = Math.abs(gamma);
        
        if (absBeta > absGamma) {
            steeringValue = beta;
            orientationInfo.textContent = "Usando Beta (Inclinaci√≥n Frontal)";
        } else {
            steeringValue = gamma;
            orientationInfo.textContent = "Usando Gamma (Inclinaci√≥n Lateral)";
        }
    }
    
    return steeringValue;
}

// Funci√≥n para manejar la orientaci√≥n del dispositivo - CORREGIDA PARA HORIZONTAL
function handleDeviceOrientation(event) {
    if (!gyroEnabled) return;
    
    const beta = event.beta;
    const gamma = event.gamma;
    const alpha = event.alpha;
    
    let steeringValue = getSteeringAxis(event);
    
    let normalizedValue = steeringValue / 90;
    
    let adjustedRotation = normalizedValue;
    if (gyroCalibrated) {
        adjustedRotation = normalizedValue - gyroCalibrationValue;
    }
    
    adjustedRotation = adjustedRotation * gyroSensitivity;
    adjustedRotation = Math.max(-gyroMaxRotation, Math.min(gyroMaxRotation, adjustedRotation));
    
    gyroRotation = adjustedRotation;
    
    // Actualizar indicador visual
    const indicatorPosition = 50 + (gyroRotation / gyroMaxRotation * 50);
    gyroIndicatorBar.style.width = `${indicatorPosition}%`;
    
    if (gyroRotation > 0.1) {
        gyroIndicatorBar.style.background = '#0f0';
    } else if (gyroRotation < -0.1) {
        gyroIndicatorBar.style.background = '#f00';
    } else {
        gyroIndicatorBar.style.background = '#0ff';
    }
    
    gyroDebug.textContent = `Beta: ${beta?.toFixed(1) || 'N/A'}¬∞ | Gamma: ${gamma?.toFixed(1) || 'N/A'}¬∞ | Alpha: ${alpha?.toFixed(1) || 'N/A'}¬∞ | Rot: ${gyroRotation.toFixed(2)}`;
}

// Bot√≥n de calibraci√≥n mejorado
calibrateGyroBtn.addEventListener('click', () => {
    if (!gyroEnabled) return;
    
    gyroStatus.textContent = "Calibrando... Mant√©n el dispositivo en posici√≥n neutral";
    
    let samples = [];
    let sampleCount = 0;
    const maxSamples = 30;
    
    const calibrationListener = (event) => {
        if (sampleCount < maxSamples) {
            const steeringValue = getSteeringAxis(event);
            samples.push(steeringValue / 90);
            sampleCount++;
        } else {
            window.removeEventListener('deviceorientation', calibrationListener);
            
            const average = samples.reduce((a, b) => a + b, 0) / samples.length;
            gyroCalibrationValue = average;
            gyroCalibrated = true;
            
            gyroStatus.textContent = "Calibraci√≥n completada";
            gyroDebug.textContent = `Calibrado: ${gyroCalibrationValue.toFixed(3)}`;
        }
    };
    
    window.addEventListener('deviceorientation', calibrationListener);
    
    setTimeout(() => {
        window.removeEventListener('deviceorientation', calibrationListener);
        if (!gyroCalibrated && samples.length > 0) {
            const average = samples.reduce((a, b) => a + b, 0) / samples.length;
            gyroCalibrationValue = average;
            gyroCalibrated = true;
            gyroStatus.textContent = "Calibraci√≥n completada";
            gyroDebug.textContent = `Calibrado: ${gyroCalibrationValue.toFixed(3)}`;
        }
    }, 3000);
});

// =========================
// Bot√≥n Posici√≥n Inicial
// =========================
const resetPositionBtn = document.getElementById("resetPositionBtn");
resetPositionBtn.addEventListener("click", resetToStartPosition);

function resetToStartPosition() {
    currentSpeed = 0;
    playerMesh.position.set(-3780, 330, -3980);
    camera.rotation.y = 0;
    
    // Resetear cron√≥metro
    isRacing = false;
    hasCrossedFinishLine = false;
    currentLapStartTime = 0;
    raceStartTime = 0;
    lapCount = 0;
    timerStatus.textContent = "ESPERANDO EN META";
    timerStatus.style.color = "#0ff";
    lapTimes.innerHTML = "";
    
    debug.textContent = "Posici√≥n inicial restaurada";
}

// =========================
// SLIDERS MEJORADOS - PROGRESI√ìN CONTINUA
// =========================
let throttlePressure = 0; // 0..1
let brakePressure = 0;    // 0..1
const throttleFill = document.getElementById('throttleFill');
const brakeFill = document.getElementById('brakeFill');
const throttleValueLabel = document.getElementById('throttleValue');
const brakeValueLabel = document.getElementById('brakeValue');
const gearIndicator = document.getElementById('gearIndicator');

// Funci√≥n mejorada para configurar sliders con progresi√≥n continua
function setupAnalogSlider(slider, fillElement, valueCallback, valueLabel) {
    let active = false;
    let touchId = null;

    // Eventos para m√∫ltiples toques
    slider.addEventListener('touchstart', e => {
        if (active) return; // Ya hay un toque activo
        
        const touch = e.changedTouches[0];
        active = true;
        touchId = touch.identifier;
        updateSlider(touch);
    }, {passive:false});

    slider.addEventListener('touchmove', e => {
        if (!active) return;
        
        // Buscar el toque correcto
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                updateSlider(e.changedTouches[i]);
                break;
            }
        }
    }, {passive:false});

    slider.addEventListener('touchend', e => {
        if (!active) return;
        
        // Verificar si es el toque correcto
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                active = false;
                touchId = null;
                valueCallback(0);
                fillElement.style.height = '0%';
                if (valueLabel) valueLabel.textContent = '0%';
                break;
            }
        }
    });

    slider.addEventListener('touchcancel', e => {
        if (!active) return;
        
        // Verificar si es el toque correcto
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                active = false;
                touchId = null;
                valueCallback(0);
                fillElement.style.height = '0%';
                if (valueLabel) valueLabel.textContent = '0%';
                break;
            }
        }
    });

    function updateSlider(touch) {
        const rect = slider.getBoundingClientRect();
        const relativeY = touch.clientY - rect.top;
        let pressure = 1 - (relativeY / rect.height);
        pressure = Math.max(0, Math.min(1, pressure));
        
        // Suavizar la transici√≥n
        fillElement.style.height = (pressure * 100) + '%';
        valueCallback(pressure);
        if (valueLabel) valueLabel.textContent = Math.round(pressure*100) + '%';
    }
}

// Configurar ambos sliders
setupAnalogSlider(document.getElementById('throttleSlider'), throttleFill, v => throttlePressure = v, throttleValueLabel);
setupAnalogSlider(document.getElementById('brakeSlider'), brakeFill, v => brakePressure = v, brakeValueLabel);

// =========================
// SISTEMA DE F√çSICA AVANZADA
// =========================

// Funci√≥n para calcular fuerzas aerodin√°micas
function calculateAerodynamicForces(speed) {
    const speedMs = speed * 0.2778; // Convertir km/h a m/s
    
    // Fuerza de resistencia aerodin√°mica
    const dragForce = 0.5 * carDrag * AIR_DENSITY * FRONTAL_AREA * speedMs * speedMs;
    
    // Fuerza de downforce (carga aerodin√°mica)
    currentDownforce = 0.5 * carDownforce * AIR_DENSITY * FRONTAL_AREA * speedMs * speedMs;
    
    return {
        drag: dragForce,
        downforce: currentDownforce
    };
}

// Funci√≥n para calcular transferencia de peso
function calculateWeightTransfer(acceleration, braking, turning) {
    const wheelbase = 2.5; // metros
    const trackWidth = 1.8; // metros
    const cogHeight = 0.5 + (carCenterOfMass * 0.3); // altura del centro de gravedad
    
    // Transferencia longitudinal (aceleraci√≥n/frenada)
    let longTransfer = 0;
    if (braking > 0) {
        longTransfer = (braking * cogHeight) / wheelbase;
    } else if (acceleration > 0) {
        longTransfer = -(acceleration * cogHeight) / wheelbase;
    }
    
    // Transferencia lateral (giro)
    const latTransfer = (turning * cogHeight) / trackWidth;
    
    return {
        longitudinal: longTransfer,
        lateral: latTransfer
    };
}

// Funci√≥n para calcular fuerzas de giro realistas
function calculateRealisticSteering(speed, steeringInput, weightTransfer) {
    const baseGrip = carTireGrip;
    const speedFactor = Math.max(0.7, 1 - (speed / maxSpeed) * 0.3);
    
    // El agarre se reduce con la transferencia de peso excesiva
    const effectiveGrip = baseGrip * (1 - Math.abs(weightTransfer.lateral) * 0.3);
    
    // Fuerza G lateral
    lateralGForce = steeringInput * effectiveGrip * speedFactor;
    
    return lateralGForce * 0.8; // Reducir para hacerlo m√°s manejable
}

// Funci√≥n para simular suspensi√≥n
function updateSuspension(dt) {
    const baseHeight = cameraHeight;
    const suspensionMovement = Math.sin(Date.now() * 0.01) * 0.05 * (Math.abs(currentSpeed) / maxSpeed);
    const brakeDip = isBraking ? -0.1 : 0;
    const accelerationSquat = isAccelerating ? -0.05 : 0;
    
    suspensionTravel = suspensionMovement + brakeDip + accelerationSquat;
    
    if (camera) {
        camera.position.y = baseHeight + suspensionTravel;
    }
}

// =========================
// BabylonJS Juego
// =========================
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.collisionsEnabled = true;

// CIELO
scene.clearColor = new BABYLON.Color4(0.4, 0.7, 1, 1);
const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
hemiLight.diffuse = new BABYLON.Color3(0.8, 0.9, 1);
hemiLight.groundColor = new BABYLON.Color3(0.2, 0.4, 0.8);
hemiLight.intensity = 1.2;

const dirLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.5), scene);
dirLight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
dirLight.intensity = 0.8;
dirLight.specular = new BABYLON.Color3(0.1, 0.1, 0.1);

scene.ambientColor = new BABYLON.Color3(0.4, 0.5, 0.7);
scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
scene.fogColor = new BABYLON.Color3(0.5, 0.5, 0.5);
scene.fogDensity = 0;

// PLAYER
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", {height: 1.8, radius: 0.3}, scene);
playerMesh.isVisible = false;
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5, 3, 0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0, 2, 0);

// CAMERA - CORREGIDO
const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, cameraHeight, 0), scene);
camera.parent = playerMesh;
camera.detachControl(canvas);

// UI
const debug = document.getElementById("debug");
const speedBar = document.getElementById("speedBar");

// MOVIMIENTO
let currentSpeed = 0;
let maxReverse = 50;
let airFriction = 8;

// JOYSTICK
const joystickHandle = document.getElementById("joystickHandle");
let isJoystickActive = false;
let joystickRotation = 0;
const rotationSpeed = 1.2;
const minSpeedForSteering = 5;

joystickContainer.addEventListener('touchstart', e => { 
    if (Math.abs(currentSpeed) < minSpeedForSteering) return; 
    e.preventDefault(); 
    isJoystickActive = true; 
    updateJoystick(e.touches[0]); 
});

joystickContainer.addEventListener('touchmove', e => { 
    if (Math.abs(currentSpeed) < minSpeedForSteering) { 
        resetJoystick(); 
        return; 
    } 
    if (!isJoystickActive) return; 
    e.preventDefault(); 
    updateJoystick(e.touches[0]); 
});

joystickContainer.addEventListener('touchend', e => { 
    e.preventDefault(); 
    isJoystickActive = false; 
    resetJoystick(); 
});

function updateJoystick(touch) { 
    const rect = joystickContainer.getBoundingClientRect(); 
    const dx = touch.clientX - (rect.left + rect.width / 2); 
    const maxDist = rect.width / 2 - joystickHandle.offsetWidth / 2; 
    const dist = Math.min(Math.abs(dx), maxDist); 
    joystickHandle.style.transform = `translate(calc(-50% + ${Math.sign(dx) * dist}px), -50%)`; 
    joystickRotation = Math.max(-1, Math.min(1, dx / maxDist)); 
}

function resetJoystick() { 
    joystickHandle.style.transform = 'translate(-50%, -50%)'; 
    joystickRotation = 0; 
}

function updateJoystickState() { 
    if (Math.abs(currentSpeed) >= minSpeedForSteering) {
        joystickContainer.classList.remove('joystick-disabled'); 
    } else { 
        joystickContainer.classList.add('joystick-disabled'); 
        if (isJoystickActive) { 
            resetJoystick(); 
            isJoystickActive = false; 
        }
    }
}


// =========================
// SISTEMA DE MARCHAS MANUAL/AUTOM√ÅTICO
// =========================
const gearUpBtn = document.getElementById("gearUp");
const gearDownBtn = document.getElementById("gearDown");
const gearModeBtn = document.getElementById("gearModeBtn");

let isManualGear = false;
let currentGear = 1;
const maxGear = 6;
const gearRatios = [0, 3.5, 2.5, 1.8, 1.3, 1.0, 0.8]; // Relaciones de marcha
let manualMaxSpeed = 0;

// Cambiar entre modo manual/autom√°tico
gearModeBtn.addEventListener('click', () => {
    isManualGear = !isManualGear;
    gearModeBtn.textContent = isManualGear ? "MANUAL" : "AUTO";
    gearModeBtn.classList.toggle('manual', isManualGear);
    
    // Mostrar/ocultar botones de cambio
    gearUpBtn.style.display = isManualGear ? 'flex' : 'none';
    gearDownBtn.style.display = isManualGear ? 'flex' : 'none';
    
    if (!isManualGear) {
        currentGear = 1; // Resetear a primera al volver a autom√°tico
    }
    
    debug.textContent = `Modo ${isManualGear ? 'MANUAL' : 'AUTOM√ÅTICO'} activado`;
});

// Cambio de marcha hacia arriba
gearUpBtn.addEventListener('click', () => {
    if (currentGear < maxGear) {
        currentGear++;
        updateGearPerformance();
        debug.textContent = `Marcha ${currentGear} engranada`;
    }
});

// Cambio de marcha hacia abajo
gearDownBtn.addEventListener('click', () => {
    if (currentGear > 1) {
        currentGear--;
        updateGearPerformance();
        debug.textContent = `Marcha ${currentGear} engranada`;
    }
});

// Actualizar rendimiento seg√∫n la marcha
function updateGearPerformance() {
    if (isManualGear) {
        manualMaxSpeed = maxSpeed * (gearRatios[currentGear] / gearRatios[1]);
        gearIndicator.textContent = currentGear;
    }
}

// En el bucle principal, modifica la f√≠sica para modo manual
// BUSCA esta parte en el bucle principal y modif√≠cala:    

// CRON√ìMETRO
const currentTimer = document.getElementById("currentTimer");
const lapTimes = document.getElementById("lapTimes");
const timerStatus = document.getElementById("timerStatus");
const bestLapDisplay = document.getElementById("bestLapDisplay");

let raceStartTime = 0;
let currentLapStartTime = 0;
let bestLapTime = 0;
let lapCount = 0;
let isRacing = false;
let hasCrossedFinishLine = false;
let prevPosZ = 0;

const finishLine = {
    minX: -3800,
    maxX: -3700, 
    z: -4025,
    width: 30,
    resetThresholdExtra: 10
};

finishLine.centerX = (finishLine.minX + finishLine.maxX) / 2;
finishLine.resetThreshold = finishLine.width + finishLine.resetThresholdExtra;

function formatTime(ms) {
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    const msr = Math.floor(ms % 1000);
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${msr.toString().padStart(3, '0')}`;
}

function updateTimerDisplay() { 
    currentTimer.textContent = isRacing ? formatTime(Date.now() - currentLapStartTime) : "00:00.000"; 
    bestLapDisplay.textContent = bestLapTime > 0 ? `MEJOR VUELTA: ${formatTime(bestLapTime)}` : "MEJOR VUELTA: --:--.---"; 
}

function registerCross() { 
    if (!isRacing) {
        isRacing = true; 
        raceStartTime = Date.now(); 
        currentLapStartTime = raceStartTime; 
        lapCount = 1; 
        timerStatus.textContent = "VUELTA 1"; 
        timerStatus.style.color = "#0f0"; 
        return;
    } 
    
    const lapTime = Date.now() - currentLapStartTime; 
    if (bestLapTime === 0 || lapTime < bestLapTime) bestLapTime = lapTime; 
    
    const lapEl = document.createElement("div"); 
    lapEl.className = "lap-time"; 
    lapEl.textContent = `Vuelta ${lapCount}: ${formatTime(lapTime)}` + (lapTime === bestLapTime ? " ‚òÖ" : ""); 
    if (lapTime === bestLapTime) lapEl.classList.add("best-lap"); 
    lapTimes.insertBefore(lapEl, lapTimes.firstChild); 
    
    lapCount++; 
    currentLapStartTime = Date.now(); 
    
    if (lapCount > totalLaps) { 
        timerStatus.textContent = "CARRERA COMPLETADA"; 
        isRacing = false; 
    } else { 
        timerStatus.textContent = `VUELTA ${lapCount}`; 
    }
}

function checkFinishLine() { 
    const pos = playerMesh.position; 
    const insideX = (pos.x >= finishLine.minX && pos.x <= finishLine.maxX); 
    
    if (insideX) { 
        if (!hasCrossedFinishLine && prevPosZ < finishLine.z && pos.z >= finishLine.z && Math.abs(pos.z - finishLine.z) <= finishLine.width) { 
            hasCrossedFinishLine = true; 
            registerCross(); 
        } else if (!hasCrossedFinishLine && prevPosZ > finishLine.z && pos.z <= finishLine.z && Math.abs(pos.z - finishLine.z) <= finishLine.width) { 
            hasCrossedFinishLine = true; 
            registerCross(); 
        } 
    } 
    
    if (Math.abs(pos.z - finishLine.z) > finishLine.resetThreshold) hasCrossedFinishLine = false; 
    prevPosZ = pos.z; 
}

// CARGAR CIRCUITO
BABYLON.SceneLoader.Append("", "spa.glb", scene, () => {
    scene.meshes.forEach(m => { 
        if (m !== playerMesh) m.checkCollisions = true; 
    });
    playerMesh.position.set(-3780, 330, -3980); 
    prevPosZ = playerMesh.position.z;
    debug.textContent = "Circuito cargado - L√≠nea de meta activa";
}, null, (s, msg) => { 
    console.error(msg); 
    debug.textContent = 'Error cargando spa.glb'; 
});

function keepGround() { 
    const ray = new BABYLON.Ray(
        playerMesh.position.add(new BABYLON.Vector3(0, 10, 0)), 
        new BABYLON.Vector3(0, -1, 0), 
        50
    ); 
    const hit = scene.pickWithRay(ray, m => m !== playerMesh); 
    if (hit && hit.hit) playerMesh.position.y = hit.pickedPoint.y + 2; 
}

const maxRealKmH = 330;
const speedFactor = maxRealKmH / maxSpeed;

// BUCLE PRINCIPAL - F√çSICA AVANZADA COMPLETA
engine.runRenderLoop(() => {
    // Clima
    switch(weatherSelect.value) {
        case 'sunny': 
            scene.clearColor = new BABYLON.Color4(0.4, 0.7, 1, 1); 
            break;
        case 'gray': 
            scene.clearColor = new BABYLON.Color4(0.5, 0.5, 0.5, 1); 
            break;
        case 'sunset': 
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.2, 1); 
            break;
    }

    const dt = engine.getDeltaTime() / 1000;
    
    // CALCULAR FUERZAS AERODIN√ÅMICAS
    const aeroForces = calculateAerodynamicForces(Math.abs(currentSpeed * speedFactor));
    
    // DETECTAR ESTADOS
    isBraking = brakePressure > 0.1;
    isAccelerating = throttlePressure > 0.1;
    
    // CALCULAR TRANSFERENCIA DE PESO
    const weightTransfer = calculateWeightTransfer(
        throttlePressure, 
        brakePressure, 
        Math.abs(gyroEnabled ? gyroRotation : joystickRotation)
    );
    
    // F√çSICA MEJORADA CON PESO Y AERODIN√ÅMICA
    let effectiveMass = carWeight + (currentDownforce / GRAVITY);
    let accelerationForce = (accel * throttlePressure) * (carWeight / 1000);
    let brakingForce = (brakeFriction * brakePressure) * (carWeight / 1000);
    
    // Aplicar resistencia aerodin√°mica
    const dragDeceleration = (aeroForces.drag / effectiveMass) * dt;
    
    // L√≥gica de movimiento con f√≠sica realista
    // L√≥gica de movimiento con sistema de marchas
if (throttlePressure > 0) {
    if (isManualGear) {
        // Modo manual - limitado por la marcha actual
        currentSpeed = Math.min(currentSpeed + accelerationForce * dt, manualMaxSpeed);
    } else {
        // Modo autom√°tico - velocidad completa
        currentSpeed = Math.min(currentSpeed + accelerationForce * dt, maxSpeed);
    }
} 
    else if (brakePressure > 0) {
        if (currentSpeed > 0) {
            currentSpeed = Math.max(currentSpeed - (brakingForce + dragDeceleration) * dt, 0);
            if (currentSpeed === 0 && brakePressure > 0.1) {
                currentSpeed = -brakePressure * 3 * (carWeight / 1000);
            }
        } 
        else if (currentSpeed < 0) {
            currentSpeed = Math.max(currentSpeed - brakingForce * dt, -maxReverse);
        }
        else {
            currentSpeed = -brakePressure * 3 * (carWeight / 1000);
        }
    }
    else {
        // Fricci√≥n natural + resistencia aerodin√°mica
        if (currentSpeed > 0) {
            currentSpeed = Math.max(currentSpeed - (airFriction + dragDeceleration) * dt, 0);
        } else if (currentSpeed < 0) {
            currentSpeed = Math.min(currentSpeed + (airFriction + dragDeceleration) * dt, 0);
        }
    }

    updateJoystickState();
    
    // CONTROL DE DIRECCI√ìN MEJORADO CON F√çSICA
    let steeringRotation = 0;
    if (gyroEnabled && Math.abs(currentSpeed) >= minSpeedForSteering) {
        const realisticSteering = calculateRealisticSteering(
            Math.abs(currentSpeed * speedFactor), 
            gyroRotation, 
            weightTransfer
        );
        steeringRotation = realisticSteering * rotationSpeed * dt;
    } else if (isJoystickActive && Math.abs(joystickRotation) > 0.1 && Math.abs(currentSpeed) >= minSpeedForSteering) {
        const realisticSteering = calculateRealisticSteering(
            Math.abs(currentSpeed * speedFactor), 
            joystickRotation, 
            weightTransfer
        );
        steeringRotation = realisticSteering * rotationSpeed * dt;
    }
    
    // Aplicar giro con efecto de peso
    if (steeringRotation !== 0) {
        // Los coches m√°s pesados giran m√°s lentamente
        const weightSteeringFactor = Math.max(0.9, 1 - (carWeight - 800) / 10000);
        camera.rotation.y += steeringRotation * weightSteeringFactor;
    }
    
    // Actualizar indicador de marcha
if (isManualGear) {
    // En manual, mostrar la marcha actual
    if (currentSpeed > 0) {
        gearIndicator.textContent = currentGear;
    } else if (currentSpeed < 0) {
        gearIndicator.textContent = "R";
    } else {
        gearIndicator.textContent = "N";
    }
} else {
    // En autom√°tico, calcular marcha aproximada
    if (currentSpeed > 0) {
        gearIndicator.textContent = Math.floor(currentSpeed / 50) + 1;
    } else if (currentSpeed < 0) {
        gearIndicator.textContent = "R";
    } else {
        gearIndicator.textContent = "N";
    }
                                                  }
    
    // Actualizar barra de velocidad
    speedBar.style.width = (Math.min(Math.abs(currentSpeed) / maxSpeed, 1) * 100) + "%";
    speedBar.style.background = currentSpeed >= 0 ? "#0f0" : "#f00";
    
    // Mover el coche
    if (Math.abs(currentSpeed) > 0.001) { 
        const yaw = camera.rotation.y; 
        const forward = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw)); 
        playerMesh.moveWithCollisions(forward.scale(currentSpeed * speedFactor * dt)); 
    }
    
    // Actualizar suspensi√≥n
    updateSuspension(dt);
    
    checkFinishLine(); 
    updateTimerDisplay(); 
    keepGround();
    
    debug.textContent = `Coche: ${cars[currentCar].name} | Peso: ${carWeight}kg | Vel: ${(currentSpeed * speedFactor).toFixed(0)} km/h | Downforce: ${currentDownforce.toFixed(0)}N | G-Lateral: ${lateralGForce.toFixed(2)}g`;
    
    // Actualizar indicador de velocidad num√©rico
    document.getElementById('speedNumber').textContent = Math.abs(currentSpeed * speedFactor).toFixed(0) + ' km/h';
    
    scene.render();
});

window.addEventListener('resize', () => engine.resize());
</script>
</body>
</html>
