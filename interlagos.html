<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Interlagos - Simulaci贸n de Conducci贸n Realista - MULTIJUGADOR</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a0a0a">
<script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth-compat.js"></script>
<style>
html,body{margin:0;overflow:hidden;height:100%;background:#000}
#renderCanvas{width:100%;height:100%}
.button{position:absolute;bottom:30px;width:80px;height:80px;background:rgba(255,255,255,0.25);border-radius:50%;pointer-events:auto;}
#btnForward{right:40px}
#btnBackward{right:140px}
#speedBarContainer{position:absolute;top:10px;left:100px;width:200px;height:20px;background:#444;border:1px solid #fff}
#speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
#debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
#joystickContainer { position: absolute; bottom: 30px; left: 50px; width: 160px; height: 120px; pointer-events: auto; z-index: 10; }
#joystickBase { position: absolute; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); }
#joystickHandle { position: absolute; width: 50px; height: 100px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s; }
#joystickAxis { position: absolute; width: 100%; height: 1px; background: rgba(255, 255, 255, 0.2); top: 50%; left: 0; transform: translateY(-50%); }
.joystick-disabled { opacity: 0.5; pointer-events: none; }

/* CRONMETRO MOVIDO A LA DERECHA ARRIBA */
#timerPanel { 
    position: absolute; 
    top: 10px; 
    right: 10px; 
    width: 140px; 
    background: rgba(0,0,0,0.7); 
    border: 2px solid #fff; 
    border-radius: 10px; 
    padding: 5px; 
    color: #fff; 
    font-family: monospace; 
    z-index: 10; 
    font-size: 12px;
}
#currentTimer { font-size: 18px; text-align: center; margin-bottom: 5px; color: #0f0; }
#lapTimes { font-size: 10px; max-height: 100px; overflow-y: auto; }
.lap-time { padding: 1px 0; border-bottom: 1px solid #444; }
.lap-time:last-child { border-bottom: none; }
.best-lap { color: #ff0; font-weight: bold; }
#timerStatus { text-align: center; font-size: 12px; margin-top: 2px; color: #0ff; }
#bestLapDisplay { text-align: center; font-size: 12px; margin-top: 2px; color: #ff0; }

/* Bot贸n pantalla completa */
#fullscreenBtn{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    padding:15px 25px;
    font-size:20px;
    background:rgba(0,0,0,0.7);
    color:#0f0;
    border:2px solid #0f0;
    border-radius:10px;
    z-index:100;
}

/* Botones configuraci贸n y coches */
#settingsBtn, #carsBtn, #leaderboardBtn, #multiplayerBtn {
    position:absolute;
    top:5px;
    width:40px;
    height:40px;
    background:rgba(255,255,255,0.25);
    border-radius:50%;
    font-size:28px;
    text-align:center;
    line-height:50px;
    cursor:pointer;
    z-index:100;
}
#settingsBtn{ left:100px; }
#carsBtn{ left:50px; font-size:30px; }
#leaderboardBtn{ left:150px; font-size:24px; }
#multiplayerBtn{ left:200px; font-size:24px; }

/* Paneles */
.settings-panel, .leaderboard-panel, .multiplayer-panel {
    position:absolute;
    top:60px;
    left:150px;
    width:240px;
    background:rgba(0,0,0,0.95);
    border:2px solid #fff;
    border-radius:10px;
    padding:15px;
    color:#fff;
    font-family:monospace;
    display:none;
    z-index:101;
    max-height:80vh;
    overflow-y:auto;
}
.settings-panel label{display:block;margin:8px 0 4px;font-size:14px;}
.settings-panel input[type=range]{width:100%;margin:5px 0;}
.settings-panel select, .settings-panel input[type=number]{width:100%;margin-bottom:8px;padding:4px;}
.settings-panel button{width:100%;padding:8px;margin-top:8px;}

/* Estilos espec铆ficos para el panel de coches */
.car-option {
    padding: 10px;
    margin: 5px 0;
    background: rgba(255,255,255,0.1);
    border-radius: 5px;
    cursor: pointer;
    border: 1px solid transparent;
}
.car-option:hover {
    background: rgba(255,255,255,0.2);
    border-color: #0f0;
}
.car-option.selected {
    background: rgba(0,255,0,0.2);
    border-color: #0f0;
}
.car-stats {
    font-size: 12px;
    color: #ccc;
    margin-top: 5px;
}

/* Bot贸n posici贸n inicial */
#resetPositionBtn{
    position:absolute;
    top:5px;
    left:10px;
    width:40px;
    height:40px;
    background:rgba(255,255,255,0.25);
    border-radius:50%;
    pointer-events:auto;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:24px;
    color:white;
}

/* Indicador de calibraci贸n de giroscopio */
#gyroIndicator {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 20px;
    background: rgba(0,0,0,0.7);
    border: 1px solid #fff;
    border-radius: 10px;
    display: none;
    z-index: 10;
    display: none !important;
}

#gyroIndicatorBar {
    height: 100%;
    width: 50%;
    background: #0f0;
    border-radius: 10px;
    transition: width 0.1s;
    display: none !important;
}

/* Indicador de orientaci贸n */
#orientationInfo {
    display: none !important; /* OCULTAR COMPLETAMENTE */
    position: absolute;
    top: 35px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    font-family: monospace;
    display: none;
    z-index: 10;
}

/* Sliders tipo volumen (acelerador/freno) - MEJORADOS */
.slider {
    position: absolute;
    bottom: 30px;
    width: 80px;
    height: 200px;
    background: rgba(255,255,255,0.06);
    border-radius: 20px;
    border: 2px solid rgba(255,255,255,0.08);
    touch-action: none;
    z-index: 20;
    display: flex;
    align-items: flex-end;
    overflow: hidden;
}
#throttleSlider{ right: 30px; }
#brakeSlider{ right: 130px; left: auto; }
.slider-fill {
    width: 100%;
    height: 0%;
    background: linear-gradient(180deg, rgba(0,255,0,0.25), rgba(0,255,0,0.6));
    border-radius: 16px 16px 6px 6px;
    transition: height 0.05s;
}
#brakeFill {
    background: linear-gradient(180deg, rgba(255,0,0,0.25), rgba(255,0,0,0.6));
}
.slider-label{position:absolute;top:-22px;right:0;font-size:12px;color:#fff;font-family:monospace}

/* Indicadores num茅ricos peque帽os */
.pedal-value{
    position:absolute;
    bottom:240px;
    right:30px;
    color:#fff;
    font-family:monospace;
    font-size:12px;
    z-index:21;
}
.pedal-value.brake{ right:130px; left: auto; }

/* Indicador de marcha */
#gearIndicator {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 5px 15px;
    border-radius: 5px;
    font-size: 14px;
    font-family: monospace;
    z-index: 10;
    border: 1px solid #fff;
}

/* Indicador de velocidad num茅rico */
#speedNumber {
    position: absolute;
    bottom: 50px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #0f0;
    padding: 5px 15px;
    border-radius: 5px;
    font-size: 18px;
    font-family: monospace;
    z-index: 10;
    border: 1px solid #0f0;
    font-weight: bold;
}

/* Indicador de RPM */
#rpmIndicator {
    position: absolute;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #0f0;
    padding: 5px 15px;
    border-radius: 5px;
    font-size: 16px;
    font-family: monospace;
    z-index: 10;
    border: 1px solid #0f0;
    display: flex;
    align-items: bottom;
    gap: 8px;
}

#rpmBar {
    width: 60px;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
}

#rpmFill {
    height: 100%;
    width: 0%;
    background: #0f0;
    border-radius: 4px;
    transition: width 0.1s, background 0.3s;
}

/* Controles de cambio de marchas */
#gearControls {
    position: absolute;
    bottom: 250px;
    left: 50%;
    transform: translateX(-50%);
    display: none; /* Ocultos por defecto, se muestran en modo manual */
    gap: 20px;
    align-items: center;
    z-index: 25;
}

/* Botones de cambio de marchas - A LOS LADOS */
/* Botones de cambio de marchas - CORREGIDOS */
.gear-btn {
    width: 60px;
    height: 60px;
    background: rgba(255,255,255,0.2);
    border: 2px solid #fff;
    border-radius: 50%;
    color: #fff;
    font-size: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    transition: all 0.2s;
    z-index: 25;
    /* AADE ESTO para prevenir el recuadro de Google */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    touch-action: manipulation;
    pointer-events: auto;
}

.gear-btn:active {
    background: rgba(255,255,255,0.4);
    transform: scale(0.95);
}

#gearDown {
    pointer-events: auto;
    position: absolute;
    top: 130px; /* MITAD de la altura de los sliders (que miden 200px) */
    left: 220px; /* A la DERECHA del freno */
}

#gearUp {
    pointer-events: auto;
    position: absolute;
    top: 60px; /* MITAD de la altura de los sliders */
    left: 220px;   /* A la IZQUIERDA del acelerador */
}

#gearModeBtn {
    position: absolute;
    bottom: 200px; /* Encima de los botones de marchas */
    left: 50%;
    transform: translateX(-50%);
    width: 120px;
    height: 40px;
    border-radius: 20px;
    font-size: 14px;
    background: rgba(0,255,0,0.3);
    border: 2px solid #0f0;
    color: #fff;
    cursor: pointer;
    z-index: 25;
    /* A帽ade tambi茅n esto para prevenir el recuadro */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    touch-action: manipulation;
}

#gearModeBtn.manual {
    background: rgba(255,255,0,0.3);
    border-color: #ff0;
}


/* Ocultar barra de velocidad de arriba */
#speedBarContainer {
    display: none;
}

/* Ocultar texto de debug de arriba */
#debug {
    display: none;
}

/* Ocultar n煤meros y texto del RPM, dejar solo la barra */
#rpmIndicator {
    background: transparent;
    border: none;
    padding: 0;
    bottom: 90px; /* Ajustar posici贸n si es necesario */
}

#rpmIndicator span {
    display: none; /* Ocultar texto "RPM" y n煤meros */
}

#rpmBar {
    width: 100px; /* Hacer la barra m谩s ancha */
    height: 12px; /* Hacer la barra m谩s gruesa */
    background: rgba(0,0,0,0.3); /* Fondo semitransparente para la barra */
    border-radius: 6px;
}

#rpmFill {
    height: 100%;
    border-radius: 6px;
}    

/* SISTEMA DE DAO - NUEVO */
#damageIndicator {
    position: absolute;
    top: 0px;
    right: 10px;
    width: 145px;
    height: 10px;
    background: rgba(0,0,0,0.7);
    border: 1px solid #fff;
    border-radius: 10px;
    z-index: 10;
    display: flex;
    align-items: center;
    padding: 0 5px;
}

#damageBar {
    height: 70%;
    width: 100%;
    background: #333;
    border-radius: 5px;
    overflow: hidden;
    position: relative;
}

#damageFill {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #0f0, #ff0, #f00);
    border-radius: 5px;
    transition: width 0.3s;
}

#damageText {
    position: absolute;
    left: 0;
    right: 0;
    text-align: center;
    font-size: 10px;
    color: #fff;
    font-family: monospace;
    font-weight: bold;
    text-shadow: 1px 1px 1px #000;
}

#crashMessage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9);
    color: #f00;
    padding: 20px 40px;
    border-radius: 10px;
    font-size: 24px;
    font-family: monospace;
    text-align: center;
    z-index: 100;
    border: 3px solid #f00;
    display: none;
    box-shadow: 0 0 20px rgba(255,0,0,0.5);
}

#crashMessage p {
    margin: 10px 0;
    font-size: 16px;
    color: #fff;
}

.damage-effect {
    position: absolute;
    top: 0;
    right: 10;
    width: 50%;
    height: 50%;
    pointer-events: none;
    z-index: 5;
    opacity: 0;
    transition: opacity 0.3s;
}

#screenCracks {
    background: radial-gradient(circle at 30% 30%, transparent 50%, rgba(255,0,0,0.1) 70%),
                radial-gradient(circle at 70% 70%, transparent 50%, rgba(255,0,0,0.1) 70%);
}

#redOverlay {
    background: rgba(255,0,0,0.1);
}

/* Indicador de fantasma activo */
#ghostIndicator {
    position: absolute;
    top: 35px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: #e8f4f8;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    font-family: monospace;
    z-index: 10;
    border: 1px solid #e8f4f8;
    display: none;
    display: none !important;
}

/* NUEVO: Vista en primera persona del F1 - MEJORADA */
#f1CockpitView {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: url('https://i.ibb.co/G34CHGsk/1000024931.png');
    background-size: 120% auto;
    background-position: center 30%;
    background-repeat: no-repeat;
    z-index: 5;
    pointer-events: none;
    display: none;
    opacity: 1;
    transform: none !important;
}

/* Controles de ajuste de la vista F1 */
#cockpitControls {
    position: absolute;
    top: 100px;
    left: 10px;
    background: rgba(0,0,0,0.8);
    border: 1px solid #0f0;
    border-radius: 5px;
    padding: 10px;
    color: #fff;
    font-family: monospace;
    font-size: 12px;
    z-index: 102;
    display: none;
}

.cockpit-control {
    margin: 5px 0;
}

.cockpit-control label {
    display: block;
    margin-bottom: 2px;
}

.cockpit-control input {
    width: 100%;
}

#cockpitAdjustBtn {
    position: absolute;
    top: 50px;
    left: 10px;
    width: 40px;
    height: 40px;
    background: rgba(255,255,255,0.25);
    border-radius: 50%;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    cursor: pointer;
    z-index: 101;
}

/* NUEVO: ESPEJO RETROVISOR - CENTRADO Y MS PEQUEO */
#rearviewMirror {
    position: absolute;
    top: 10px;
    right: -100px;
    transform: translateX(-50%);
    width: 200px;
    height: 50px; /* Reducido a la mitad de altura */
    background: rgba(0,0,0,0.8);
    border: 2px solid #fff;
    border-radius: 5px;
    z-index: 10;
    overflow: hidden;
    box-shadow: 0 0 10px rgba(255,255,255,0.3);
}

#rearviewCanvas {
    width: 100%;
    height: 100%;
}

#mirrorLabel {
    position: absolute;
    top: 2px;
    left: 5px;
    color: #fff;
    font-size: 10px;
    font-family: monospace;
    z-index: 11;
    text-shadow: 1px 1px 1px #000;
}

/* NUEVO: ESTILOS PARA EL SISTEMA DE CLASIFICACIN */
.leaderboard-panel {
    width: 300px;
    max-height: 70vh;
    overflow-y: auto;
}

.leaderboard-header {
    text-align: center;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #0f0;
}

.leaderboard-entry {
    display: flex;
    justify-content: space-between;
    padding: 5px 0;
    border-bottom: 1px solid #333;
}

.leaderboard-position {
    font-weight: bold;
    width: 30px;
}

.leaderboard-name {
    flex-grow: 1;
    text-align: left;
    padding: 0 10px;
}

.leaderboard-time {
    width: 100px;
    text-align: right;
    font-family: monospace;
}

.leaderboard-current {
    background: rgba(0, 255, 0, 0.1);
    border-left: 3px solid #0f0;
}

.leaderboard-podium {
    background: rgba(255, 215, 0, 0.1);
    border-left: 3px solid #ff0;
}

#usernameInput {
    width: 100%;
    padding: 8px;
    margin: 10px 0;
    background: rgba(255,255,255,0.1);
    border: 1px solid #0f0;
    border-radius: 5px;
    color: #fff;
    font-family: monospace;
}

#submitTimeBtn {
    width: 100%;
    padding: 10px;
    background: rgba(0,255,0,0.3);
    border: 1px solid #0f0;
    border-radius: 5px;
    color: #fff;
    font-family: monospace;
    cursor: pointer;
    margin-top: 10px;
}

#submitTimeBtn:hover {
    background: rgba(0,255,0,0.5);
}

#leaderboardMessage {
    text-align: center;
    margin-top: 10px;
    font-size: 12px;
    color: #0f0;
}

/* NUEVO: ESTILOS PARA EL MODO MULTIJUGADOR */
.multiplayer-panel {
    width: 280px;
}

.multiplayer-header {
    text-align: center;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 1px solid #0ff;
}

.multiplayer-status {
    font-size: 12px;
    margin-bottom: 10px;
    padding: 5px;
    border-radius: 5px;
    text-align: center;
}

.multiplayer-status.connected {
    background: rgba(0, 255, 0, 0.2);
    border: 1px solid #0f0;
}

.multiplayer-status.disconnected {
    background: rgba(255, 0, 0, 0.2);
    border: 1px solid #f00;
}

.player-list {
    max-height: 200px;
    overflow-y: auto;
    margin-bottom: 10px;
}

.player-item {
    display: flex;
    justify-content: space-between;
    padding: 5px;
    border-bottom: 1px solid #333;
    font-size: 12px;
}

.player-name {
    font-weight: bold;
}

.player-car {
    color: #ccc;
}

.player-lap {
    color: #0ff;
}

.chat-container {
    border-top: 1px solid #444;
    padding-top: 10px;
}

.chat-messages {
    height: 150px;
    overflow-y: auto;
    background: rgba(255,255,255,0.05);
    border-radius: 5px;
    padding: 5px;
    margin-bottom: 10px;
    font-size: 12px;
}

.chat-message {
    margin-bottom: 5px;
    padding: 3px;
}

.chat-message.system {
    color: #0ff;
    font-style: italic;
}

.chat-message.player {
    color: #fff;
}

.chat-input {
    display: flex;
    gap: 5px;
}

.chat-input input {
    flex-grow: 1;
    padding: 5px;
    background: rgba(255,255,255,0.1);
    border: 1px solid #0ff;
    border-radius: 5px;
    color: #fff;
    font-size: 12px;
}

.chat-input button {
    padding: 5px 10px;
    background: rgba(0,255,255,0.3);
    border: 1px solid #0ff;
    border-radius: 5px;
    color: #fff;
    cursor: pointer;
}

#multiplayerBtn.active {
    background: rgba(0,255,255,0.4);
    border: 2px solid #0ff;
}

</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<!-- NUEVO: Vista en primera persona del F1 MEJORADA -->
<div id="f1CockpitView"></div>

<!-- NUEVO: Espejo retrovisor CENTRADO Y MS PEQUEO -->
<div id="rearviewMirror">
    <canvas id="rearviewCanvas"></canvas>
    <div id="mirrorLabel"></div>
</div>

<!-- Controles de ajuste de vista F1 -->
<div id="cockpitControls">
    <h4 style="margin:0 0 8px 0;text-align:center;">AJUSTE VISTA F1</h4>
    <div class="cockpit-control">
        <label>Tama帽o: <span id="cockpitSizeValue">120</span>%</label>
        <input type="range" id="cockpitSizeRange" min="80" max="200" value="120">
    </div>
    <div class="cockpit-control">
        <label>Posici贸n Vertical: <span id="cockpitPositionValue">30</span>%</label>
        <input type="range" id="cockpitPositionRange" min="-500" max="60" value="30">
    </div>
    <div class="cockpit-control">
        <label>Posici贸n Horizontal: <span id="cockpitHorizontalValue">50</span>%</label>
        <input type="range" id="cockpitHorizontalRange" min="30" max="70" value="50">
    </div>
    <button id="closeCockpitControls" style="width:100%;margin-top:5px;">Cerrar</button>
</div>

<!-- Bot贸n para ajustar vista F1 -->
<div id="cockpitAdjustBtn"></div>

<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito...</div>
<div id="resetPositionBtn" title="Posici贸n Inicial"></div>

<!-- Indicadores en la parte inferior -->
<div id="rpmIndicator">
    <span>RPM</span>
    <div id="rpmBar"><div id="rpmFill"></div></div>
    <span id="rpmValue">0</span>
</div>
<div id="speedNumber">0 km/h</div>
<div id="gearIndicator">N</div>

<!-- Controles de cambio de marchas (solo visibles en modo manual) -->
<div id="gearControls">
    <div class="gear-btn" id="gearDown">-</div>
    <div class="gear-btn" id="gearUp">+</div>
</div>

<!-- Indicador de calibraci贸n de giroscopio -->
<div id="gyroIndicator">
    <div id="gyroIndicatorBar"></div>
</div>

<!-- Informaci贸n de orientaci贸n -->
<div id="orientationInfo"></div>

<!-- Joystick -->
<div id="joystickContainer" class="joystick-disabled">
  <div id="joystickBase">
    <div id="joystickAxis"></div>
    <div id="joystickHandle"></div>
  </div>
</div>

<!-- Sliders tipo volumen para acelerador y freno -->
<div id="throttleSlider" class="slider" aria-label="Acelerador">
    <div id="throttleFill" class="slider-fill"></div>
    <div class="slider-label">Acel</div>
</div>
<div id="brakeSlider" class="slider" aria-label="Freno">
    <div id="brakeFill" class="slider-fill"></div>
    <div class="slider-label">Freno</div>
</div>
<div class="pedal-value" id="throttleValue">0%</div>
<div class="pedal-value brake" id="brakeValue">0%</div>

<!-- CRONMETRO MOVIDO A LA DERECHA ARRIBA -->
<div id="timerPanel">
  <div id="currentTimer">00:00.000</div>
  <div id="lapTimes"></div>
  <div id="timerStatus">ESPERANDO EN META</div>
  <div id="bestLapDisplay">MEJOR VUELTA: --:--.---</div>
</div>

<!-- Botones -->
<button id="fullscreenBtn">Pantalla Completa</button>
<div id="settingsBtn">锔</div>
<div id="carsBtn"></div>
<div id="leaderboardBtn"></div>
<div id="multiplayerBtn"></div> <!-- NUEVO: Bot贸n de multijugador -->

<!-- Panel de Configuraci贸n -->
<div id="settingsPanel" class="settings-panel">
    <label>Velocidad M谩x: <span id="maxSpeedLabel">330</span> km/h</label>
    <input type="range" id="maxSpeedRange" min="50" max="500" value="330">
    
    <label>Aceleraci贸n 0-100: <span id="accelLabel">2.0</span>s</label>
    <input type="range" id="accelRange" min="1.5" max="6.0" step="0.1" value="2.0">

    <label>Freno: <span id="brakeLabel">150</span></label>
    <input type="range" id="brakeRange" min="20" max="300" value="150">

    <label>Altura de C谩mara: <span id="cameraHeightLabel">1.0</span> m</label>
    <input type="range" id="cameraHeightRange" min="1.0" max="6.0" step="0.1" value="1.0">

    <!-- NUEVO: Control de sensibilidad del joystick -->
    <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
        <label>Sensibilidad Joystick: <span id="joystickSensitivityLabel">1.0</span></label>
        <input type="range" id="joystickSensitivityRange" min="0.1" max="3.0" step="0.1" value="1.0">
        <div style="font-size: 12px; color: #ccc; margin-top: 5px;">
            Ajusta la sensibilidad del joystick de direcci贸n
        </div>
    </div>

    <!-- Control de transmisi贸n -->
    <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
        <label style="display: flex; align-items: center; justify-content: space-between;">
            <span>Transmisi贸n Manual</span>
            <input type="checkbox" id="manualTransmissionToggle" style="width: auto;">
        </label>
        <div id="manualTransmissionInfo" style="font-size: 12px; color: #ccc; margin-top: 5px;">
            Activa para control manual de marchas
        </div>
    </div>

    <!-- NUEVO: Control de fantasma -->
    <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
        <label style="display: flex; align-items: center; justify-content: space-between;">
            <span>Mostrar Fantasma</span>
            <input type="checkbox" id="ghostToggle" style="width: auto;" checked>
        </label>
        <div style="font-size: 12px; color: #ccc; margin-top: 5px;">
            Muestra tu mejor vuelta como coche fantasma
        </div>
    </div>

    <!-- Nuevos controles para giroscopio -->
    <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
        <label style="display: flex; align-items: center; justify-content: space-between;">
            <span>Control por Giroscopio</span>
            <input type="checkbox" id="gyroToggle" style="width: auto;">
        </label>
        
        <div id="gyroControls" style="display: none;">
            <label>Sensibilidad: <span id="gyroSensitivityLabel">1.0</span></label>
            <input type="range" id="gyroSensitivityRange" min="0.1" max="8.0" step="0.1" value="1.0">
            
            <label>M谩ximo Giro: <span id="gyroMaxLabel">2.0</span></label>
            <input type="range" id="gyroMaxRange" min="0.5" max="8.0" step="0.1" value="2.0">
            
            <label>Modo de Control</label>
            <select id="gyroModeSelect">
                <option value="beta">Inclinaci贸n Frontal (Beta)</option>
                <option value="gamma">Inclinaci贸n Lateral (Gamma)</option>
                <option value="auto">Autom谩tico (Recomendado)</option>
            </select>
            
            <button id="calibrateGyroBtn">Calibrar Giroscopio</button>
            <div style="font-size: 12px; margin-top: 5px; color: #ccc;">
                <div>Gira el dispositivo como un volante</div>
                <div id="gyroStatus">Estado: No disponible</div>
                <div id="gyroDebug" style="font-size: 10px; margin-top: 3px;"></div>
            </div>
        </div>
    </div>

    <label>Clima</label>
    <select id="weatherSelect">
        <option value="sunny">Soleado</option>
        <option value="gray">Cielo Gris</option>
        <option value="sunset">Atardecer Azul</option>
    </select>
    <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 10px;">
        <label>Intensidad de Luz: <span id="lightIntensityLabel">1.2</span></label>
        <input type="range" id="lightIntensityRange" min="0.1" max="3.0" step="0.1" value="1.2" style="width:100%">
    </div>

    <label>M煤sica</label>
    <button id="musicBtn">On</button>

    <label>N煤mero de Vueltas</label>
    <input type="number" id="lapsNumber" min="1" max="99" value="3">
</div>

<!-- Panel de Selecci贸n de Coches -->
<div id="carsPanel" class="settings-panel">
    <h3 style="text-align:center;margin-top:0;">SELECCIONAR COCHE</h3>
    
    <div class="car-option selected" data-car="f1">
        <strong>F贸rmula 1</strong>
        <div class="car-stats">Vel: 350 km/h | 0-100: 1.8s | 8 Marchas | Peso: 740kg</div>
    </div>
    
    <div class="car-option" data-car="gt3">
        <strong>GT3</strong>
        <div class="car-stats">Vel: 300 km/h | 0-100: 2.5s | 6 Marchas | Peso: 1250kg</div>
    </div>
    
    <div class="car-option" data-car="gt4">
        <strong>GT4</strong>
        <div class="car-stats">Vel: 250 km/h | 0-100: 3.2s | 6 Marchas | Peso: 1350kg</div>
    </div>
    
    <div class="car-option" data-car="hypercar">
        <strong>Hypercar</strong>
        <div class="car-stats">Vel: 400 km/h | 0-100: 2.2s | 7 Marchas | Peso: 1100kg</div>
    </div>
    
    <div class="car-option" data-car="touring">
        <strong>Touring Car</strong>
        <div class="car-stats">Vel: 280 km/h | 0-100: 3.5s | 6 Marchas | Peso: 1150kg</div>
    </div>
    
    <div class="car-option" data-car="rally">
        <strong>Rally</strong>
        <div class="car-stats">Vel: 220 km/h | 0-100: 4.0s | 6 Marchas | Peso: 1300kg</div>
    </div>
    
    <div class="car-option" data-car="drift">
        <strong>Drift Car</strong>
        <div class="car-stats">Vel: 240 km/h | 0-100: 3.8s | 6 Marchas | Peso: 1200kg</div>
    </div>
</div>

<!-- NUEVO: Panel de Clasificaci贸n -->
<div id="leaderboardPanel" class="leaderboard-panel">
    <div class="leaderboard-header">
        <h3 style="margin:0 0 5px 0;"> CLASIFICACIN </h3>
        <div style="font-size:12px;color:#ccc;">Top 100 Mejores Tiempos</div>
    </div>
    
    <div id="leaderboardList">
        <!-- La lista se llenar谩 din谩micamente -->
    </div>
    
    <div style="margin-top:15px;border-top:1px solid #444;padding-top:10px;">
        <h4 style="margin:0 0 8px 0;text-align:center;">GUARDAR TU TIEMPO</h4>
        <input type="text" id="usernameInput" placeholder="Tu nombre de usuario" maxlength="20">
        <button id="submitTimeBtn">GUARDAR TIEMPO</button>
        <div id="leaderboardMessage"></div>
    </div>
</div>

<!-- NUEVO: Panel de Multijugador -->
<div id="multiplayerPanel" class="multiplayer-panel">
    <div class="multiplayer-header">
        <h3 style="margin:0 0 5px 0;"> MODO MULTIJUGADOR</h3>
        <div style="font-size:12px;color:#ccc;">Conecta con otros pilotos</div>
    </div>
    
    <div id="multiplayerStatus" class="multiplayer-status disconnected">
        Desconectado
    </div>
    
    <div style="margin-bottom:10px;">
        <input type="text" id="playerNameInput" placeholder="Tu nombre de piloto" maxlength="15" style="width:100%;padding:8px;background:rgba(255,255,255,0.1);border:1px solid #0ff;border-radius:5px;color:#fff;">
        <button id="connectMultiplayerBtn" style="width:100%;padding:8px;margin-top:5px;background:rgba(0,255,255,0.3);border:1px solid #0ff;border-radius:5px;color:#fff;cursor:pointer;">
            CONECTAR
        </button>
        <button id="disconnectMultiplayerBtn" style="width:100%;padding:8px;margin-top:5px;background:rgba(255,0,0,0.3);border:1px solid #f00;border-radius:5px;color:#fff;cursor:pointer;display:none;">
            DESCONECTAR
        </button>
    </div>
    
    <div class="player-list">
        <h4 style="margin:0 0 8px 0;text-align:center;">JUGADORES CONECTADOS</h4>
        <div id="playersList">
            <!-- Lista de jugadores se llenar谩 din谩micamente -->
        </div>
    </div>
    
    <div class="chat-container">
        <h4 style="margin:0 0 8px 0;text-align:center;">CHAT</h4>
        <div id="chatMessages" class="chat-messages">
            <!-- Mensajes de chat -->
        </div>
        <div class="chat-input">
            <input type="text" id="chatInput" placeholder="Escribe un mensaje..." maxlength="100">
            <button id="sendChatBtn">Enviar</button>
        </div>
    </div>
</div>

<!-- SISTEMA DE DAO - NUEVO -->
<div id="damageIndicator">
    <div id="damageBar">
        <div id="damageFill"></div>
        <div id="damageText">DAO: 0%</div>
    </div>
</div>

<!-- Indicador de fantasma activo -->
<div id="ghostIndicator">FANTASMA ACTIVO</div>

<div id="crashMessage">
    <h2>隆CHOQUE!</h2>
    <p>El coche ha sufrido da帽os cr铆ticos</p>
    <p>Volviendo a la posici贸n inicial...</p>
</div>

<div id="screenCracks" class="damage-effect"></div>
<div id="redOverlay" class="damage-effect"></div>

<audio id="motorAudio" src="motor.mp3" loop></audio>
<audio id="crashSound" src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=="></audio>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// =========================
// CONFIGURACIN DE FIREBASE (CREDENCIALES)
// =========================
const firebaseConfig = {
    apiKey: "AIzaSyD-6cYCCemWH6FtXzpq849jdh4o7BRAObM",
    authDomain: "racing-a64f6.firebaseapp.com",
    databaseURL: "https://racing-a64f6-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "racing-a64f6",
    storageBucket: "racing-a64f6.firebasestorage.app",
    messagingSenderId: "642406724818",
    appId: "1:642406724818:web:176ad0fcec39d99687690b"
};

// Inicializar Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();
const auth = firebase.auth();

// =========================
// SISTEMA MULTIJUGADOR MEJORADO - COCHES 3D IGUAL QUE EL FANTASMA
// =========================
const multiplayerBtn = document.getElementById("multiplayerBtn");
const multiplayerPanel = document.getElementById("multiplayerPanel");
const playerNameInput = document.getElementById("playerNameInput");
const connectMultiplayerBtn = document.getElementById("connectMultiplayerBtn");
const disconnectMultiplayerBtn = document.getElementById("disconnectMultiplayerBtn");
const multiplayerStatus = document.getElementById("multiplayerStatus");
const playersList = document.getElementById("playersList");
const chatMessages = document.getElementById("chatMessages");
const chatInput = document.getElementById("chatInput");
const sendChatBtn = document.getElementById("sendChatBtn");

let isMultiplayerConnected = false;
let playerId = null;
let playerName = "";
let otherPlayers = {};
let playerRef = null;
let playersRef = null;
let chatRef = null;

// Inicializar sistema multijugador
function initMultiplayerSystem() {
    multiplayerBtn.addEventListener('click', () => {
        multiplayerPanel.style.display = multiplayerPanel.style.display === 'none' ? 'block' : 'none';
        settingsPanel.style.display = 'none';
        carsPanel.style.display = 'none';
        leaderboardPanel.style.display = 'none';
    });
    
    connectMultiplayerBtn.addEventListener('click', connectToMultiplayer);
    disconnectMultiplayerBtn.addEventListener('click', disconnectFromMultiplayer);
    sendChatBtn.addEventListener('click', sendChatMessage);
    
    chatInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendChatMessage();
        }
    });
    
    // Generar ID 煤nico para el jugador
    playerId = generatePlayerId();
}

function generatePlayerId() {
    return 'player_' + Math.random().toString(36).substr(2, 9);
}

function connectToMultiplayer() {
    const name = playerNameInput.value.trim();
    if (!name) {
        alert("Por favor, ingresa tu nombre de piloto");
        return;
    }
    
    playerName = name;
    
    // Conectar a Firebase
    playerRef = database.ref('players/' + playerId);
    playersRef = database.ref('players');
    chatRef = database.ref('chat');
    
    // Configurar listeners
    playersRef.on('value', updatePlayersList);
    chatRef.limitToLast(20).on('value', updateChat);
    
    // Enviar datos del jugador
    updatePlayerData();
    
    // Actualizar UI
    multiplayerStatus.textContent = "Conectado";
    multiplayerStatus.className = "multiplayer-status connected";
    connectMultiplayerBtn.style.display = 'none';
    disconnectMultiplayerBtn.style.display = 'block';
    multiplayerBtn.classList.add('active');
    isMultiplayerConnected = true;
    
    // Enviar mensaje de sistema
    sendSystemMessage(`${playerName} se ha unido a la carrera`);
    
    // Iniciar actualizaci贸n peri贸dica de posici贸n
    startPositionUpdates();
}

function disconnectFromMultiplayer() {
    if (playerRef) {
        // Eliminar jugador de la base de datos
        playerRef.remove();
    }
    
    // Remover listeners
    if (playersRef) playersRef.off();
    if (chatRef) chatRef.off();
    
    // Limpiar coches de otros jugadores
    clearOtherPlayers();
    
    // Actualizar UI
    multiplayerStatus.textContent = "Desconectado";
    multiplayerStatus.className = "multiplayer-status disconnected";
    connectMultiplayerBtn.style.display = 'block';
    disconnectMultiplayerBtn.style.display = 'none';
    multiplayerBtn.classList.remove('active');
    isMultiplayerConnected = false;
    
    // Enviar mensaje de sistema
    if (playerName) {
        sendSystemMessage(`${playerName} ha abandonado la carrera`);
    }
    
    playerName = "";
}

function updatePlayerData() {
    if (!playerRef || !isMultiplayerConnected) return;
    
    const playerData = {
        name: playerName,
        car: currentCar,
        position: {
            x: playerMesh.position.x,
            y: playerMesh.position.y,
            z: playerMesh.position.z
        },
        rotation: camera.rotation.y,
        speed: currentSpeed,
        lap: lapCount,
        lastUpdate: Date.now()
    };
    
    playerRef.set(playerData);
}

function updatePlayersList(snapshot) {
    const players = snapshot.val();
    playersList.innerHTML = '';
    otherPlayers = {};
    
    if (!players) return;
    
    Object.keys(players).forEach(key => {
        if (key === playerId) return; // Saltar el jugador actual
        
        const player = players[key];
        otherPlayers[key] = player;
        
        // Actualizar lista de jugadores
        const playerItem = document.createElement('div');
        playerItem.className = 'player-item';
        playerItem.innerHTML = `
            <span class="player-name">${player.name}</span>
            <span class="player-car">${getCarName(player.car)}</span>
            <span class="player-lap">Vuelta ${player.lap || 1}</span>
        `;
        playersList.appendChild(playerItem);
        
        // Actualizar coche del jugador en el mundo 3D
        updateOtherPlayerInWorld(key, player);
    });
}

//  NUEVA FUNCIN MEJORADA: Crear coches 3D IDNTICOS al fantasma
function updateOtherPlayerInWorld(playerId, playerData) {
    let playerCar = scene.getTransformNodeByName(`otherPlayer_${playerId}`);
    
    if (!playerCar) {
        // Crear coche 3D IDNTICO al fantasma
        playerCar = createOtherPlayerCar(playerId, playerData.car);
    }
    
    if (playerCar) {
        // Actualizar posici贸n y rotaci贸n
        playerCar.position.set(
            playerData.position.x,
            playerData.position.y,
            playerData.position.z
        );
        playerCar.rotation.y = playerData.rotation;
        
        // Mantener el coche en el suelo
        keepOtherPlayerOnGround(playerCar);
        
        // Actualizar nombre flotante
        updatePlayerNameTag(playerId, playerData.name, playerCar.position);
    }
}

//  CREAR COCHE 3D IDNTICO AL FANTASMA
function createOtherPlayerCar(playerId, carType) {
    // Crear grupo principal para el coche - IDNTICO AL FANTASMA
    const carGroup = new BABYLON.TransformNode(`otherPlayer_${playerId}`, scene);
    
    // CHASIS PRINCIPAL - Forma aerodin谩mica de F1 (IGUAL QUE FANTASMA)
    const mainChassis = BABYLON.MeshBuilder.CreateCylinder(`otherPlayer_chassis_${playerId}`, {
        diameterTop: 0.8,
        diameterBottom: 1.2,
        height: 5,
        tessellation: 6
    }, scene);
    mainChassis.parent = carGroup;
    mainChassis.rotation.x = Math.PI / 2; // Rotar para que sea horizontal
    
    // CABINA - Cockpit tipo F1 (IGUAL QUE FANTASMA)
    const cockpit = BABYLON.MeshBuilder.CreateBox(`otherPlayer_cockpit_${playerId}`, {
        width: 0.9,
        height: 0.4,
        depth: 1.2
    }, scene);
    cockpit.parent = carGroup;
    cockpit.position.y = 0.3;
    cockpit.position.z = -0.5;
    
    // ALERN TRASERO - Ala posterior grande (IGUAL QUE FANTASMA)
    const rearWing = BABYLON.MeshBuilder.CreateBox(`otherPlayer_rearWing_${playerId}`, {
        width: 2.5,
        height: 0.1,
        depth: 0.4
    }, scene);
    rearWing.parent = carGroup;
    rearWing.position.z = -2.2;
    rearWing.position.y = 0.8;
    
    // SOPORTES ALERN TRASERO (IGUAL QUE FANTASMA)
    const wingSupport1 = BABYLON.MeshBuilder.CreateCylinder(`otherPlayer_wingSupport1_${playerId}`, {
        height: 0.7,
        diameter: 0.08
    }, scene);
    wingSupport1.parent = carGroup;
    wingSupport1.position.set(-0.8, 0.35, -2.2);
    
    const wingSupport2 = BABYLON.MeshBuilder.CreateCylinder(`otherPlayer_wingSupport2_${playerId}`, {
        height: 0.7,
        diameter: 0.08
    }, scene);
    wingSupport2.parent = carGroup;
    wingSupport2.position.set(0.8, 0.35, -2.2);
    
    // ALERN DELANTERO (IGUAL QUE FANTASMA)
    const frontWing = BABYLON.MeshBuilder.CreateBox(`otherPlayer_frontWing_${playerId}`, {
        width: 2.2,
        height: 0.05,
        depth: 0.6
    }, scene);
    frontWing.parent = carGroup;
    frontWing.position.z = 2.0;
    frontWing.position.y = 0.1;
    
    // RUEDAS MS GRANDES Y DETALLADAS (IGUAL QUE FANTASMA)
    const wheelPositions = [
        { x: 0.7, y: -0.3, z: 1.3 },   // Delantera derecha
        { x: -0.7, y: -0.3, z: 1.3 },  // Delantera izquierda
        { x: 0.7, y: -0.3, z: -1.3 },  // Trasera derecha
        { x: -0.7, y: -0.3, z: -1.3 }  // Trasera izquierda
    ];
    
    wheelPositions.forEach((pos, index) => {
        // Llanta (IGUAL QUE FANTASMA)
        const wheel = BABYLON.MeshBuilder.CreateCylinder(`otherPlayer_wheel_${playerId}_${index}`, {
            diameter: 1.0, // M谩s grande
            height: 0.5
        }, scene);
        wheel.parent = carGroup;
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos.x, pos.y, pos.z);
        
        // Neum谩tico (aro exterior) (IGUAL QUE FANTASMA)
        const tire = BABYLON.MeshBuilder.CreateTorus(`otherPlayer_tire_${playerId}_${index}`, {
            diameter: 1.0,
            thickness: 0.15,
            tessellation: 16
        }, scene);
        tire.parent = carGroup;
        tire.rotation.z = Math.PI / 2;
        tire.position.set(pos.x, pos.y, pos.z);
    });
    
    // Aleta laterales (IGUAL QUE FANTASMA)
    const sidePod1 = BABYLON.MeshBuilder.CreateBox(`otherPlayer_sidePod1_${playerId}`, {
        width: 0.3,
        height: 0.2,
        depth: 2.5
    }, scene);
    sidePod1.parent = carGroup;
    sidePod1.position.set(0.5, 0.1, 0);
    
    const sidePod2 = BABYLON.MeshBuilder.CreateBox(`otherPlayer_sidePod2_${playerId}`, {
        width: 0.3,
        height: 0.2,
        depth: 2.5
    }, scene);
    sidePod2.parent = carGroup;
    sidePod2.position.set(-0.5, 0.1, 0);
    
    // ESCALA FINAL - Hacer el coche m谩s grande (IGUAL QUE FANTASMA)
    carGroup.scaling.set(4, 4, 4);
    
    // Material con color 煤nico por jugador - MS VISIBLE
    const playerColor = getPlayerColor(playerId);
    const carMaterial = new BABYLON.StandardMaterial(`otherPlayerMaterial_${playerId}`, scene);
    carMaterial.diffuseColor = playerColor;
    carMaterial.alpha = 0.9; // Menos transparente que el fantasma
    carMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    carMaterial.emissiveColor = playerColor.scale(0.3); // Brillo suave
    
    // Aplicar material a todas las partes del coche
    carGroup.getChildMeshes().forEach(mesh => {
        mesh.material = carMaterial;
        mesh.checkCollisions = false;
        mesh.isPickable = false;
    });
    
    return carGroup;
}

//  MANTENER COCHES EN EL SUELO
function keepOtherPlayerOnGround(carMesh) {
    const ray = new BABYLON.Ray(
        carMesh.position.add(new BABYLON.Vector3(0, 10, 0)),
        new BABYLON.Vector3(0, -1, 0),
        50
    );
    const hit = scene.pickWithRay(ray, m => {
        return m !== carMesh && 
               m !== playerMesh && 
               m !== ghostCar &&
               !m.name.includes('otherPlayer') &&
               !m.name.includes('nameTag');
    });
    
    if (hit && hit.hit) {
        carMesh.position.y = hit.pickedPoint.y + 2;
    }
}

//  ETIQUETAS DE NOMBRE FLOTANTES
function updatePlayerNameTag(playerId, playerName, position) {
    let nameTag = scene.getMeshByName(`nameTag_${playerId}`);
    
    if (!nameTag) {
        // Crear plano para el nombre
        nameTag = BABYLON.MeshBuilder.CreatePlane(`nameTag_${playerId}`, {
            width: 3,
            height: 0.5
        }, scene);
        
        // Crear material con texto
        const nameMaterial = new BABYLON.StandardMaterial(`nameMaterial_${playerId}`, scene);
        nameMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
        nameMaterial.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        nameMaterial.backFaceCulling = false;
        
        // Usar DynamicTexture para el texto
        const dynamicTexture = new BABYLON.DynamicTexture(`nameTexture_${playerId}`, {
            width: 256,
            height: 64
        }, scene);
        
        const ctx = dynamicTexture.getContext();
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0, 0, 256, 64);
        ctx.font = "bold 24px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.fillText(playerName, 128, 40);
        
        dynamicTexture.update();
        nameMaterial.diffuseTexture = dynamicTexture;
        nameTag.material = nameMaterial;
        
        // Hacer que siempre mire hacia la c谩mara
        nameTag.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    }
    
    // Posicionar encima del coche
    nameTag.position = position.add(new BABYLON.Vector3(0, 6, 0));
}

function getPlayerColor(playerId) {
    // Generar color 煤nico basado en el ID del jugador
    const colors = [
        new BABYLON.Color3(1, 0, 0),    // Rojo
        new BABYLON.Color3(0, 0, 1),    // Azul
        new BABYLON.Color3(0, 1, 0),    // Verde
        new BABYLON.Color3(1, 1, 0),    // Amarillo
        new BABYLON.Color3(1, 0, 1),    // Magenta
        new BABYLON.Color3(0, 1, 1),    // Cian
        new BABYLON.Color3(1, 0.5, 0),  // Naranja
        new BABYLON.Color3(0.5, 0, 1),  // P煤rpura
    ];
    
    // Hash simple del playerId para seleccionar color
    let hash = 0;
    for (let i = 0; i < playerId.length; i++) {
        hash = playerId.charCodeAt(i) + ((hash << 5) - hash);
    }
    return colors[Math.abs(hash) % colors.length];
}

function clearOtherPlayers() {
    // Eliminar todos los coches de otros jugadores
    scene.meshes.forEach(mesh => {
        if (mesh.name && mesh.name.startsWith('otherPlayer_')) {
            mesh.dispose();
        }
        if (mesh.name && mesh.name.startsWith('nameTag_')) {
            mesh.dispose();
        }
    });
    otherPlayers = {};
}

function getCarName(carType) {
    const carNames = {
        'f1': 'F1',
        'gt3': 'GT3',
        'gt4': 'GT4',
        'hypercar': 'Hypercar',
        'touring': 'Touring',
        'rally': 'Rally',
        'drift': 'Drift'
    };
    return carNames[carType] || 'Coche';
}

function updateChat(snapshot) {
    const messages = snapshot.val();
    chatMessages.innerHTML = '';
    
    if (!messages) return;
    
    Object.values(messages).forEach(message => {
        const messageElement = document.createElement('div');
        messageElement.className = `chat-message ${message.type || 'player'}`;
        
        if (message.type === 'system') {
            messageElement.textContent = message.text;
        } else {
            messageElement.innerHTML = `<strong>${message.player}:</strong> ${message.text}`;
        }
        
        chatMessages.appendChild(messageElement);
    });
    
    // Auto-scroll al final
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function sendChatMessage() {
    const text = chatInput.value.trim();
    if (!text || !isMultiplayerConnected) return;
    
    const message = {
        player: playerName,
        text: text,
        timestamp: Date.now()
    };
    
    chatRef.push(message);
    chatInput.value = '';
}

function sendSystemMessage(text) {
    if (!isMultiplayerConnected) return;
    
    const message = {
        type: 'system',
        text: text,
        timestamp: Date.now()
    };
    
    chatRef.push(message);
}

function startPositionUpdates() {
    // Actualizar posici贸n cada 200ms
    setInterval(() => {
        if (isMultiplayerConnected) {
            updatePlayerData();
        }
    }, 200);
}

// =========================
// NUEVO: SISTEMA DE CLASIFICACIN
// =========================
const leaderboardBtn = document.getElementById("leaderboardBtn");
const leaderboardPanel = document.getElementById("leaderboardPanel");
const leaderboardList = document.getElementById("leaderboardList");
const usernameInput = document.getElementById("usernameInput");
const submitTimeBtn = document.getElementById("submitTimeBtn");
const leaderboardMessage = document.getElementById("leaderboardMessage");

// Configuraci贸n de JSONBin
const BIN_ID = "69259cad43b1c97be9c4306b";
const MASTER_KEY = "$2a$10$e9MLZJQsvHcSL8qYL8U4nuBk8w41S89TqZvJBPkvhLJ6V52EZoi8m";
const ACCESS_KEY = "Racing";
const ACCESS_KEY_VALUE = "$2a$10$pQYPTeWLg8v5o3wkLS8I.OIHS2jZGpsanyHgS8QdUhnntNtX2e83";

let leaderboardData = [];
let currentUsername = "";

// Inicializar sistema de clasificaci贸n
function initLeaderboardSystem() {
    leaderboardBtn.addEventListener('click', () => {
        leaderboardPanel.style.display = leaderboardPanel.style.display === 'none' ? 'block' : 'none';
        settingsPanel.style.display = 'none';
        carsPanel.style.display = 'none';
        multiplayerPanel.style.display = 'none';
        
        if (leaderboardPanel.style.display === 'block') {
            loadLeaderboard();
        }
    });
    
    submitTimeBtn.addEventListener('click', submitBestTime);
    
    // Cargar clasificaci贸n al iniciar
    loadLeaderboard();
}

// Cargar clasificaci贸n desde JSONBin
async function loadLeaderboard() {
    try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}/latest`, {
            headers: {
                'X-Master-Key': MASTER_KEY,
                'X-Access-Key': ACCESS_KEY_VALUE
            }
        });
        
        if (!response.ok) {
            throw new Error('Error al cargar la clasificaci贸n');
        }
        
        const data = await response.json();
        leaderboardData = data.record.leaderboard || [];
        
        // Ordenar por tiempo (menor a mayor)
        leaderboardData.sort((a, b) => a.time - b.time);
        
        updateLeaderboardDisplay();
    } catch (error) {
        console.error('Error cargando clasificaci贸n:', error);
        leaderboardList.innerHTML = '<div style="text-align:center;color:#f00;">Error cargando clasificaci贸n</div>';
    }
}

// Actualizar visualizaci贸n de la clasificaci贸n
function updateLeaderboardDisplay() {
    if (leaderboardData.length === 0) {
        leaderboardList.innerHTML = '<div style="text-align:center;color:#ccc;">No hay tiempos registrados a煤n</div>';
        return;
    }
    
    let html = '';
    const maxEntries = 100; // Mostrar solo los 100 primeros
    
    leaderboardData.slice(0, maxEntries).forEach((entry, index) => {
        const position = index + 1;
        const isCurrentUser = entry.username === currentUsername && entry.time === bestLapTime;
        const isPodium = position <= 3;
        
        let entryClass = '';
        if (isCurrentUser) entryClass = 'leaderboard-current';
        if (isPodium) entryClass = 'leaderboard-podium';
        
        html += `
            <div class="leaderboard-entry ${entryClass}">
                <div class="leaderboard-position">${position}.</div>
                <div class="leaderboard-name">${entry.username}</div>
                <div class="leaderboard-time">${formatTime(entry.time)}</div>
            </div>
        `;
    });
    
    leaderboardList.innerHTML = html;
}

// Enviar mejor tiempo a la clasificaci贸n
async function submitBestTime() {
    if (!bestLapTime || bestLapTime === 0) {
        leaderboardMessage.textContent = "No tienes un mejor tiempo registrado";
        leaderboardMessage.style.color = "#f00";
        return;
    }
    
    const username = usernameInput.value.trim();
    if (!username) {
        leaderboardMessage.textContent = "Por favor, ingresa un nombre de usuario";
        leaderboardMessage.style.color = "#f00";
        return;
    }
    
    if (username.length > 20) {
        leaderboardMessage.textContent = "El nombre debe tener m谩ximo 20 caracteres";
        leaderboardMessage.style.color = "#f00";
        return;
    }
    
    currentUsername = username;
    
    // Verificar si el usuario ya existe en la clasificaci贸n
    const existingEntryIndex = leaderboardData.findIndex(entry => 
        entry.username.toLowerCase() === username.toLowerCase()
    );
    
    if (existingEntryIndex !== -1) {
        // Si el nuevo tiempo es mejor, actualizar
        if (bestLapTime < leaderboardData[existingEntryIndex].time) {
            leaderboardData[existingEntryIndex].time = bestLapTime;
            leaderboardData[existingEntryIndex].date = new Date().toISOString();
        } else {
            leaderboardMessage.textContent = "Ya tienes un tiempo mejor registrado";
            leaderboardMessage.style.color = "#ff0";
            updateLeaderboardDisplay();
            return;
        }
    } else {
        // Agregar nuevo registro
        leaderboardData.push({
            username: username,
            time: bestLapTime,
            date: new Date().toISOString(),
            car: currentCar
        });
    }
    
    // Ordenar por tiempo
    leaderboardData.sort((a, b) => a.time - b.time);
    
    // Guardar en JSONBin
    try {
        const response = await fetch(`https://api.jsonbin.io/v3/b/${BIN_ID}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Master-Key': MASTER_KEY,
                'X-Access-Key': ACCESS_KEY_VALUE
            },
            body: JSON.stringify({
                leaderboard: leaderboardData
            })
        });
        
        if (!response.ok) {
            throw new Error('Error al guardar el tiempo');
        }
        
        leaderboardMessage.textContent = "隆Tiempo guardado exitosamente!";
        leaderboardMessage.style.color = "#0f0";
        updateLeaderboardDisplay();
        
        // Limpiar campo de usuario despu茅s de guardar exitosamente
        usernameInput.value = "";
        
    } catch (error) {
        console.error('Error guardando tiempo:', error);
        leaderboardMessage.textContent = "Error al guardar el tiempo";
        leaderboardMessage.style.color = "#f00";
    }
}

// =========================
// NUEVO: ESPEJO RETROVISOR
// =========================
const rearviewCanvas = document.getElementById("rearviewCanvas");
const rearviewEngine = new BABYLON.Engine(rearviewCanvas, true);
const rearviewScene = new BABYLON.Scene(rearviewEngine);
let rearviewCamera = null;

// Funci贸n para inicializar el espejo retrovisor
function initRearviewMirror() {
    // Crear c谩mara para el espejo retrovisor
    rearviewCamera = new BABYLON.FreeCamera("rearviewCam", new BABYLON.Vector3(0, cameraHeight, 0), rearviewScene);
    rearviewCamera.parent = playerMesh;
    rearviewCamera.detachControl(rearviewCanvas);
    
    // Configurar la c谩mara para mirar hacia atr谩s
    rearviewCamera.rotation.y = Math.PI; // 180 grados - mira hacia atr谩s
    
    // Ajustar el campo de visi贸n para una vista m谩s amplia
    rearviewCamera.fov = 1.2; // Campo de visi贸n m谩s amplio
    
    // Crear el mismo cielo para la escena del espejo
    const mirrorSkySphere = BABYLON.MeshBuilder.CreateSphere("mirrorSkySphere", { 
        diameter: 10000, 
        segments: 64 
    }, rearviewScene);

    const mirrorSkyMaterial = new BABYLON.StandardMaterial("mirrorSkyMaterial", rearviewScene);
    mirrorSkyMaterial.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Vc4x5sTq/cielo.jpg", rearviewScene);
    mirrorSkyMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
    mirrorSkyMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    mirrorSkyMaterial.disableLighting = true;
    mirrorSkyMaterial.backFaceCulling = false;
    mirrorSkySphere.material = mirrorSkyMaterial;
    mirrorSkySphere.infiniteDistance = true;

    // Luces para la escena del espejo
    const mirrorHemiLight = new BABYLON.HemisphericLight("mirrorHemi", new BABYLON.Vector3(0, 1, 0), rearviewScene);
    mirrorHemiLight.diffuse = new BABYLON.Color3(0.8, 0.9, 1);
    mirrorHemiLight.groundColor = new BABYLON.Color3(0.2, 0.4, 0.8);
    mirrorHemiLight.intensity = 1.2;

    const mirrorDirLight = new BABYLON.DirectionalLight("mirrorSun", new BABYLON.Vector3(-0.5, -1, 0.5), rearviewScene);
    mirrorDirLight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
    mirrorDirLight.intensity = 0.8;

    rearviewScene.ambientColor = new BABYLON.Color3(0.4, 0.5, 0.7);
    
    // Cargar el circuito en la escena del espejo
    BABYLON.SceneLoader.Append("", "https://www.dropbox.com/scl/fi/k7v8s0fylvyzf7pje8qz7/laguna_seca.glb?rlkey=7a1ncxvhbdv5a5w6iyqc2kgvh&st=yo7oqw0d&dl=0", rearviewScene, () => {
        rearviewScene.meshes.forEach(m => { 
            if (m !== mirrorSkySphere) m.checkCollisions = true; 
        });
    }, null, (s, msg) => { 
        console.error("Error cargando circuito en espejo:", msg); 
    });
    
    // Bucle de renderizado para el espejo
    rearviewEngine.runRenderLoop(() => {
        // Sincronizar la posici贸n y rotaci贸n de la c谩mara del espejo con la c谩mara principal
        if (camera && rearviewCamera) {
            rearviewCamera.position.copyFrom(camera.position);
            rearviewCamera.rotation.y = camera.rotation.y + Math.PI; // Mirar en direcci贸n opuesta
        }
        
        // Sincronizar el clima
        switch(weatherSelect.value) {
            case 'sunny': 
                rearviewScene.clearColor = new BABYLON.Color4(0.4, 0.7, 1, 1); 
                break;
            case 'gray': 
                rearviewScene.clearColor = new BABYLON.Color4(0.5, 0.5, 0.5, 1); 
                break;
            case 'sunset': 
                rearviewScene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.2, 1); 
                break;
        }
        
        rearviewScene.render();
    });
    
    // Redimensionar el espejo cuando cambie el tama帽o de la ventana
    window.addEventListener('resize', () => rearviewEngine.resize());
}

// =========================
// NUEVO: VISTA EN PRIMERA PERSONA DEL F1 MEJORADO
// =========================
const f1CockpitView = document.getElementById('f1CockpitView');
const cockpitControls = document.getElementById('cockpitControls');
const cockpitAdjustBtn = document.getElementById('cockpitAdjustBtn');
const cockpitSizeRange = document.getElementById('cockpitSizeRange');
const cockpitPositionRange = document.getElementById('cockpitPositionRange');
const cockpitSizeValue = document.getElementById('cockpitSizeValue');
const cockpitPositionValue = document.getElementById('cockpitPositionValue');
const closeCockpitControls = document.getElementById('closeCockpitControls');
const cockpitHorizontalRange = document.getElementById('cockpitHorizontalRange'); // NUEVO
const cockpitHorizontalValue = document.getElementById('cockpitHorizontalValue'); // NUEVO
    
// Variables ajustables
let cockpitSize = 120;
let cockpitPosition = 30;
let cockpitHorizontal = 50;

// Inicializar controles
cockpitSizeRange.addEventListener('input', function() {
    cockpitSize = parseInt(this.value);
    cockpitSizeValue.textContent = cockpitSize;
    updateCockpitView();
});

cockpitPositionRange.addEventListener('input', function() {
    cockpitPosition = parseInt(this.value);
    cockpitPositionValue.textContent = cockpitPosition;
    updateCockpitView();
});

// NUEVO: Control horizontal
cockpitHorizontalRange.addEventListener('input', function() {
    cockpitHorizontal = parseInt(this.value);
    cockpitHorizontalValue.textContent = cockpitHorizontal;
    updateCockpitView();
});

closeCockpitControls.addEventListener('click', function() {
    cockpitControls.style.display = 'none';
});

cockpitAdjustBtn.addEventListener('click', function() {
    cockpitControls.style.display = cockpitControls.style.display === 'none' ? 'block' : 'none';
});

function updateCockpitView() {
    if (currentCar === 'f1') {
        f1CockpitView.style.display = 'block';
        f1CockpitView.style.backgroundImage = 'url("https://i.ibb.co/0y3Sdx2v/1000024931-1.png")';
        f1CockpitView.style.backgroundSize = cockpitSize + '% auto';
        f1CockpitView.style.backgroundPosition = cockpitHorizontal + '% ' + cockpitPosition + '%';
        cockpitAdjustBtn.style.display = 'flex';
    } else if (currentCar === 'gt3') {
        f1CockpitView.style.display = 'block';
        f1CockpitView.style.backgroundImage = 'url("https://i.ibb.co/vv36qFqn/1000024943.png")';
        f1CockpitView.style.backgroundSize = cockpitSize + '% auto';
        f1CockpitView.style.backgroundPosition = cockpitHorizontal + '% ' + cockpitPosition + '%';
        cockpitAdjustBtn.style.display = 'flex';
    } else {
        f1CockpitView.style.display = 'block';
        f1CockpitView.style.backgroundImage = 'url("https://i.ibb.co/G34CHGsk/1000024931.png")';
        f1CockpitView.style.backgroundSize = cockpitSize + '% auto';
        f1CockpitView.style.backgroundPosition = cockpitHorizontal + '% ' + cockpitPosition + '%';
        cockpitAdjustBtn.style.display = 'flex';
    }
}

// =========================
// SISTEMA DE FANTASMA MEJORADO - COCHE F1 GRANDE Y VISIBLE
// =========================
let ghostEnabled = true;
let ghostCar = null;
let ghostCarRearview = null; // NUEVO: Fantasma para el retrovisor
let ghostData = [];
let isRecordingGhost = false;
let ghostPlaybackIndex = 0;
let ghostStartTime = 0;
let currentBestLapGhostData = [];

const ghostToggle = document.getElementById("ghostToggle");
const ghostIndicator = document.getElementById("ghostIndicator");

function initGhostSystem() {
    const savedGhostData = localStorage.getItem('bestLapGhostData');
    if (savedGhostData) {
        currentBestLapGhostData = JSON.parse(savedGhostData);
    }
    
    ghostToggle.checked = ghostEnabled;
    ghostToggle.addEventListener('change', () => {
        ghostEnabled = ghostToggle.checked;
        if (!ghostEnabled && ghostCar) {
            removeGhostCar();
        }
        updateGhostIndicator();
    });
    
    updateGhostIndicator();
}

function updateGhostIndicator() {
    if (ghostEnabled && currentBestLapGhostData.length > 0) {
        ghostIndicator.style.display = 'block';
    } else {
        ghostIndicator.style.display = 'none';
    }
}

function startGhostRecording() {
    if (!ghostEnabled) return;
    isRecordingGhost = true;
    ghostData = [];
}

function stopGhostRecording() {
    isRecordingGhost = false;
}

function recordGhostData() {
    if (!isRecordingGhost || !ghostEnabled) return;
    
    const data = {
        time: Date.now() - currentLapStartTime,
        x: playerMesh.position.x,
        y: playerMesh.position.y,
        z: playerMesh.position.z,
        rotationY: camera.rotation.y,
        speed: currentSpeed
    };
    
    ghostData.push(data);
}

function saveGhostDataIfBestLap(lapTime) {
    if (!ghostEnabled || ghostData.length === 0) return;
    
    const currentBestTime = bestLapTime || Infinity;
    
    if (lapTime < currentBestTime) {
        currentBestLapGhostData = [...ghostData];
        localStorage.setItem('bestLapGhostData', JSON.stringify(currentBestLapGhostData));
    }
}

//  COCHE F1 MEJORADO - MS GRANDE, DETALLADO Y VISIBLE
function createGhostCar() {
    if (!ghostEnabled || currentBestLapGhostData.length === 0) return;
    
    // Crear grupo principal para el coche
    ghostCar = new BABYLON.TransformNode("ghostCar", scene);
    
    // CHASIS PRINCIPAL - Forma aerodin谩mica de F1
    const mainChassis = BABYLON.MeshBuilder.CreateCylinder("ghostChassis", {
        diameterTop: 0.8,
        diameterBottom: 1.2,
        height: 5,
        tessellation: 6
    }, scene);
    mainChassis.parent = ghostCar;
    mainChassis.rotation.x = Math.PI / 2; // Rotar para que sea horizontal
    
    // CABINA - Cockpit tipo F1
    const cockpit = BABYLON.MeshBuilder.CreateBox("ghostCockpit", {
        width: 0.9,
        height: 0.4,
        depth: 1.2
    }, scene);
    cockpit.parent = ghostCar;
    cockpit.position.y = 0.3;
    cockpit.position.z = -0.5;
    
    // ALERN TRASERO - Ala posterior grande
    const rearWing = BABYLON.MeshBuilder.CreateBox("ghostRearWing", {
        width: 2.5,
        height: 0.1,
        depth: 0.4
    }, scene);
    rearWing.parent = ghostCar;
    rearWing.position.z = -2.2;
    rearWing.position.y = 0.8;
    
    // SOPORTES ALERN TRASERO
    const wingSupport1 = BABYLON.MeshBuilder.CreateCylinder("wingSupport1", {
        height: 0.7,
        diameter: 0.08
    }, scene);
    wingSupport1.parent = ghostCar;
    wingSupport1.position.set(-0.8, 0.35, -2.2);
    
    const wingSupport2 = BABYLON.MeshBuilder.CreateCylinder("wingSupport2", {
        height: 0.7,
        diameter: 0.08
    }, scene);
    wingSupport2.parent = ghostCar;
    wingSupport2.position.set(0.8, 0.35, -2.2);
    
    // ALERN DELANTERO
    const frontWing = BABYLON.MeshBuilder.CreateBox("ghostFrontWing", {
        width: 2.2,
        height: 0.05,
        depth: 0.6
    }, scene);
    frontWing.parent = ghostCar;
    frontWing.position.z = 2.0;
    frontWing.position.y = 0.1;
    
    // RUEDAS MS GRANDES Y DETALLADAS
    const wheelPositions = [
        { x: 0.7, y: -0.3, z: 1.3 },   // Delantera derecha
        { x: -0.7, y: -0.3, z: 1.3 },  // Delantera izquierda
        { x: 0.7, y: -0.3, z: -1.3 },  // Trasera derecha
        { x: -0.7, y: -0.3, z: -1.3 }  // Trasera izquierda
    ];
    
    wheelPositions.forEach((pos, index) => {
        // Llanta
        const wheel = BABYLON.MeshBuilder.CreateCylinder("ghostWheel" + index, {
            diameter: 1.0, // M谩s grande
            height: 0.5
        }, scene);
        wheel.parent = ghostCar;
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos.x, pos.y, pos.z);
        
        // Neum谩tico (aro exterior)
        const tire = BABYLON.MeshBuilder.CreateTorus("ghostTire" + index, {
            diameter: 1.0,
            thickness: 0.15,
            tessellation: 16
        }, scene);
        tire.parent = ghostCar;
        tire.rotation.z = Math.PI / 2;
        tire.position.set(pos.x, pos.y, pos.z);
    });
    
    // Aleta laterales
    const sidePod1 = BABYLON.MeshBuilder.CreateBox("sidePod1", {
        width: 0.3,
        height: 0.2,
        depth: 2.5
    }, scene);
    sidePod1.parent = ghostCar;
    sidePod1.position.set(0.5, 0.1, 0);
    
    const sidePod2 = BABYLON.MeshBuilder.CreateBox("sidePod2", {
        width: 0.3,
        height: 0.2,
        depth: 2.5
    }, scene);
    sidePod2.parent = ghostCar;
    sidePod2.position.set(-0.5, 0.1, 0);
    
    // ESCALA FINAL - Hacer el coche m谩s grande (aproximadamente 2x)
    ghostCar.scaling.set(4, 4, 4);
    
    // Material fantasma mejorado - MS VISIBLE
    const ghostMaterial = new BABYLON.StandardMaterial("ghostMaterial", scene);
    ghostMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.7, 1.0); // Azul m谩s intenso
    ghostMaterial.alpha = 0.8; // Menos transparente
    ghostMaterial.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ghostMaterial.emissiveColor = new BABYLON.Color3(0.2, 0.4, 0.6); // Brillo m谩s intenso
    
    // Aplicar material a todas las partes
    ghostCar.getChildMeshes().forEach(mesh => {
        mesh.material = ghostMaterial;
        mesh.checkCollisions = false;
        mesh.isPickable = false;
    });
    
    //  NUEVO: Crear tambi茅n el coche fantasma en la escena del retrovisor
    createGhostCarInRearview();
    
    // Iniciar reproducci贸n
    ghostPlaybackIndex = 0;
    ghostStartTime = Date.now();
}

//  NUEVA FUNCIN: Crear coche fantasma en el retrovisor
function createGhostCarInRearview() {
    if (!ghostEnabled || currentBestLapGhostData.length === 0) return;
    
    // Crear grupo principal para el coche fantasma en el retrovisor
    ghostCarRearview = new BABYLON.TransformNode("ghostCarRearview", rearviewScene);
    
    // CHASIS PRINCIPAL - Forma aerodin谩mica de F1 (MISMO DISEO)
    const mainChassis = BABYLON.MeshBuilder.CreateCylinder("ghostChassisRearview", {
        diameterTop: 0.8,
        diameterBottom: 1.2,
        height: 5,
        tessellation: 6
    }, rearviewScene);
    mainChassis.parent = ghostCarRearview;
    mainChassis.rotation.x = Math.PI / 2;
    
    // CABINA - Cockpit tipo F1
    const cockpit = BABYLON.MeshBuilder.CreateBox("ghostCockpitRearview", {
        width: 0.9,
        height: 0.4,
        depth: 1.2
    }, rearviewScene);
    cockpit.parent = ghostCarRearview;
    cockpit.position.y = 0.3;
    cockpit.position.z = -0.5;
    
    // ALERN TRASERO - Ala posterior grande
    const rearWing = BABYLON.MeshBuilder.CreateBox("ghostRearWingRearview", {
        width: 2.5,
        height: 0.1,
        depth: 0.4
    }, rearviewScene);
    rearWing.parent = ghostCarRearview;
    rearWing.position.z = -2.2;
    rearWing.position.y = 0.8;
    
    // SOPORTES ALERN TRASERO
    const wingSupport1 = BABYLON.MeshBuilder.CreateCylinder("wingSupport1Rearview", {
        height: 0.7,
        diameter: 0.08
    }, rearviewScene);
    wingSupport1.parent = ghostCarRearview;
    wingSupport1.position.set(-0.8, 0.35, -2.2);
    
    const wingSupport2 = BABYLON.MeshBuilder.CreateCylinder("wingSupport2Rearview", {
        height: 0.7,
        diameter: 0.08
    }, rearviewScene);
    wingSupport2.parent = ghostCarRearview;
    wingSupport2.position.set(0.8, 0.35, -2.2);
    
    // ALERN DELANTERO
    const frontWing = BABYLON.MeshBuilder.CreateBox("ghostFrontWingRearview", {
        width: 2.2,
        height: 0.05,
        depth: 0.6
    }, rearviewScene);
    frontWing.parent = ghostCarRearview;
    frontWing.position.z = 2.0;
    frontWing.position.y = 0.1;
    
    // RUEDAS MS GRANDES Y DETALLADAS
    const wheelPositions = [
        { x: 0.7, y: -0.3, z: 1.3 },
        { x: -0.7, y: -0.3, z: 1.3 },
        { x: 0.7, y: -0.3, z: -1.3 },
        { x: -0.7, y: -0.3, z: -1.3 }
    ];
    
    wheelPositions.forEach((pos, index) => {
        const wheel = BABYLON.MeshBuilder.CreateCylinder("ghostWheelRearview" + index, {
            diameter: 1.0,
            height: 0.5
        }, rearviewScene);
        wheel.parent = ghostCarRearview;
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(pos.x, pos.y, pos.z);
        
        const tire = BABYLON.MeshBuilder.CreateTorus("ghostTireRearview" + index, {
            diameter: 1.0,
            thickness: 0.15,
            tessellation: 16
        }, rearviewScene);
        tire.parent = ghostCarRearview;
        tire.rotation.z = Math.PI / 2;
        tire.position.set(pos.x, pos.y, pos.z);
    });
    
    // Aleta laterales
    const sidePod1 = BABYLON.MeshBuilder.CreateBox("sidePod1Rearview", {
        width: 0.3,
        height: 0.2,
        depth: 2.5
    }, rearviewScene);
    sidePod1.parent = ghostCarRearview;
    sidePod1.position.set(0.5, 0.1, 0);
    
    const sidePod2 = BABYLON.MeshBuilder.CreateBox("sidePod2Rearview", {
        width: 0.3,
        height: 0.2,
        depth: 2.5
    }, rearviewScene);
    sidePod2.parent = ghostCarRearview;
    sidePod2.position.set(-0.5, 0.1, 0);
    
    // ESCALA FINAL
    ghostCarRearview.scaling.set(4, 4, 4);
    
    // Material para el retrovisor (mismo que el principal)
    const ghostMaterialRearview = new BABYLON.StandardMaterial("ghostMaterialRearview", rearviewScene);
    ghostMaterialRearview.diffuseColor = new BABYLON.Color3(0.4, 0.7, 1.0);
    ghostMaterialRearview.alpha = 0.8;
    ghostMaterialRearview.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    ghostMaterialRearview.emissiveColor = new BABYLON.Color3(0.2, 0.4, 0.6);
    
    // Aplicar material a todas las partes
    ghostCarRearview.getChildMeshes().forEach(mesh => {
        mesh.material = ghostMaterialRearview;
        mesh.checkCollisions = false;
        mesh.isPickable = false;
    });
}

function updateGhostCar() {
    if ((!ghostCar && !ghostCarRearview) || currentBestLapGhostData.length === 0) return;
    
    const currentTime = Date.now() - ghostStartTime;
    
    // Encontrar el frame actual
    while (ghostPlaybackIndex < currentBestLapGhostData.length - 1 && 
           currentBestLapGhostData[ghostPlaybackIndex + 1].time <= currentTime) {
        ghostPlaybackIndex++;
    }
    
    if (ghostPlaybackIndex < currentBestLapGhostData.length) {
        const currentFrame = currentBestLapGhostData[ghostPlaybackIndex];
        const nextFrame = currentBestLapGhostData[ghostPlaybackIndex + 1];
        
        // Interpolaci贸n suave
        let x, y, z, rotationY;
        if (nextFrame && currentFrame.time !== nextFrame.time) {
            const factor = (currentTime - currentFrame.time) / (nextFrame.time - currentFrame.time);
            x = currentFrame.x + (nextFrame.x - currentFrame.x) * factor;
            y = currentFrame.y + (nextFrame.y - currentFrame.y) * factor;
            z = currentFrame.z + (nextFrame.z - currentFrame.z) * factor;
            rotationY = currentFrame.rotationY + (nextFrame.rotationY - currentFrame.rotationY) * factor;
        } else {
            x = currentFrame.x;
            y = currentFrame.y;
            z = currentFrame.z;
            rotationY = currentFrame.rotationY;
        }
        
        //  ACTUALIZAR AMBOS COCHES FANTASMA (principal y retrovisor)
        if (ghostCar) {
            ghostCar.position.set(x, y, z);
            ghostCar.rotation.y = rotationY;
        }
        
        if (ghostCarRearview) {
            ghostCarRearview.position.set(x, y, z);
            ghostCarRearview.rotation.y = rotationY;
        }
    } else {
        removeGhostCar();
    }
}

function removeGhostCar() {
    if (ghostCar) {
        // Eliminar todos los hijos primero
        ghostCar.getChildMeshes().forEach(mesh => {
            mesh.dispose();
        });
        ghostCar.dispose();
        ghostCar = null;
    }
    
    //  NUEVO: Eliminar tambi茅n el coche fantasma del retrovisor
    if (ghostCarRearview) {
        ghostCarRearview.getChildMeshes().forEach(mesh => {
            mesh.dispose();
        });
        ghostCarRearview.dispose();
        ghostCarRearview = null;
    }
    
    ghostPlaybackIndex = 0;
}

function resetGhost() {
    removeGhostCar();
    if (ghostEnabled && currentBestLapGhostData.length > 0) {
        setTimeout(() => {
            createGhostCar();
        }, 500);
    }
}

// =========================
// SISTEMA DE DAO POR CHOQUES - NUEVO
// =========================
let carHealth = 100;
let lastCollisionTime = 0;
let collisionCooldown = 1000; // 1 segundo entre colisiones
let isCarDestroyed = false;
let crashEffectTimeout = null;

// Elementos de UI para el sistema de da帽o
const damageFill = document.getElementById('damageFill');
const damageText = document.getElementById('damageText');
const crashMessage = document.getElementById('crashMessage');
const screenCracks = document.getElementById('screenCracks');
const redOverlay = document.getElementById('redOverlay');

// Inicializar el sistema de da帽o
function initDamageSystem() {
    updateDamageUI();
}

// Actualizar la UI de da帽o
function updateDamageUI() {
    const healthPercentage = Math.max(0, carHealth);
    damageFill.style.width = `${healthPercentage}%`;
    damageText.textContent = `DAO: ${100 - healthPercentage}%`;
    
    // Cambiar color seg煤n el da帽o
    if (healthPercentage > 70) {
        damageFill.style.background = 'linear-gradient(90deg, #0f0, #0f0)';
    } else if (healthPercentage > 30) {
        damageFill.style.background = 'linear-gradient(90deg, #0f0, #ff0)';
    } else {
        damageFill.style.background = 'linear-gradient(90deg, #ff0, #f00)';
    }
}

// Aplicar da帽o al coche
function applyDamage(damageAmount) {
    if (isCarDestroyed) return;
    
    carHealth = Math.max(0, carHealth - damageAmount);
    updateDamageUI();
    
    // Efectos visuales de da帽o
    showDamageEffects(damageAmount);
    
    // Verificar si el coche est谩 destruido
    if (carHealth <= 0) {
        destroyCar();
    }
}

// Mostrar efectos visuales de da帽o
function showDamageEffects(damageAmount) {
    // Parpadeo rojo
    redOverlay.style.opacity = '0.3';
    setTimeout(() => {
        redOverlay.style.opacity = '0';
    }, 200);
    
    // Grietas en la pantalla seg煤n el da帽o
    if (damageAmount > 15) {
        screenCracks.style.opacity = '0.1';
        if (crashEffectTimeout) clearTimeout(crashEffectTimeout);
        crashEffectTimeout = setTimeout(() => {
            screenCracks.style.opacity = '0';
        }, 1000);
    }
}

// Destruir el coche
function destroyCar() {
    isCarDestroyed = true;
    
    // Mostrar mensaje de choque
    crashMessage.style.display = 'block';
    
    // Efectos visuales intensos
    screenCracks.style.opacity = '0.3';
    redOverlay.style.opacity = '0.4';
    
    // Reproducir sonido de choque (simulado)
    try {
        const crashSound = document.getElementById('crashSound');
        crashSound.play().catch(e => console.log("No se pudo reproducir sonido de choque"));
    } catch (e) {
        console.log("Error reproduciendo sonido de choque");
    }
    
    // Deshabilitar controles
    disableCarControls();
    
    // Volver a la posici贸n inicial despu茅s de 3 segundos
    setTimeout(() => {
        resetAfterCrash();
    }, 3000);
}

// Deshabilitar controles del coche
function disableCarControls() {
    // El coche se vuelve incontrolable
    // La f铆sica ya se encargar谩 de que no responda bien
    currentSpeed = currentSpeed * 0.5; // Reducir velocidad dr谩sticamente
    
    // A帽adir efectos de p茅rdida de control
    camera.rotation.y += Math.random() * 0.1 - 0.05; // Temblor de c谩mara
}

// Reiniciar despu茅s del choque
function resetAfterCrash() {
    // Ocultar mensaje y efectos
    crashMessage.style.display = 'none';
    screenCracks.style.opacity = '0';
    redOverlay.style.opacity = '0';
    
    // Reparar el coche
    carHealth = 100;
    isCarDestroyed = false;
    updateDamageUI();
    
    // Volver a la posici贸n inicial
    resetToStartPosition();
    
    // Rehabilitar controles (se har谩 autom谩ticamente al resetear posici贸n)
}

// Detectar colisiones
function checkCollisions() {
    if (isCarDestroyed) return;
    
    const currentTime = Date.now();
    if (currentTime - lastCollisionTime < collisionCooldown) return;
    
    // Crear un rayo hacia adelante para detectar colisiones
    const forward = new BABYLON.Vector3(
        Math.sin(camera.rotation.y),
        0,
        Math.cos(camera.rotation.y)
    );
    
    const rayOrigin = playerMesh.position.add(new BABYLON.Vector3(0, 1, 0));
    const ray = new BABYLON.Ray(rayOrigin, forward, 5);
    const hit = scene.pickWithRay(ray, m => {
        return m !== playerMesh && 
               m !== skySphere && 
               m !== ghostCar &&
               !m.name.includes('otherPlayer') &&
               !m.name.includes('nameTag');
    });
    
    if (hit && hit.hit && hit.distance < 3) {
        // Calcular da帽o basado en la velocidad
        const speedKmh = Math.abs(currentSpeed * speedFactor);
        const damage = calculateCollisionDamage(speedKmh);
        
        if (damage > 0) {
            applyDamage(damage);
            lastCollisionTime = currentTime;
            
            // Aplicar fuerza de rebote
            currentSpeed = -currentSpeed * 0.3;
        }
    }
}

// Calcular da帽o basado en la velocidad
function calculateCollisionDamage(speedKmh) {
    if (speedKmh < 10) return 0; // Sin da帽o a baja velocidad
    
    // F贸rmula: m谩s da帽o a mayor velocidad
    let damage = 0;
    
    if (speedKmh < 30) {
        damage = 5 + (speedKmh - 10) * 0.25;
    } else if (speedKmh < 60) {
        damage = 10 + (speedKmh - 30) * 0.5;
    } else if (speedKmh < 100) {
        damage = 25 + (speedKmh - 60) * 0.75;
    } else {
        damage = 55 + (speedKmh - 100) * 1.0;
    }
    
    // Considerar el tipo de coche (los m谩s ligeros sufren m谩s da帽o)
    const car = cars[currentCar];
    const weightFactor = 1500 / car.weight; // Coches m谩s ligeros = m谩s da帽o
    damage *= weightFactor;
    
    return Math.min(damage, 50); // M谩ximo 50 de da帽o por colisi贸n
}

// =========================
// Fullscreen
// =========================
const fullscreenBtn = document.getElementById("fullscreenBtn");
fullscreenBtn.addEventListener('click', () => {
    document.documentElement.requestFullscreen?.().catch(() => {});
    if (screen.orientation && screen.orientation.lock) screen.orientation.lock("landscape").catch(() => {});
    fullscreenBtn.style.display = 'none';
});

// =========================
// Configuraci贸n
// =========================
const settingsBtn = document.getElementById("settingsBtn");
const carsBtn = document.getElementById("carsBtn");
const settingsPanel = document.getElementById("settingsPanel");
const carsPanel = document.getElementById("carsPanel");

settingsBtn.addEventListener('click', () => { 
    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
    carsPanel.style.display = 'none';
    leaderboardPanel.style.display = 'none';
    multiplayerPanel.style.display = 'none';
});

carsBtn.addEventListener('click', () => { 
    carsPanel.style.display = carsPanel.style.display === 'none' ? 'block' : 'none';
    settingsPanel.style.display = 'none';
    leaderboardPanel.style.display = 'none';
    multiplayerPanel.style.display = 'none';
});

// AADE ESTO DESPUS de los otros event listeners de configuraci贸n
const lightIntensityRange = document.getElementById("lightIntensityRange");
const lightIntensityLabel = document.getElementById("lightIntensityLabel");

lightIntensityRange.addEventListener('input', function() {
    const intensity = parseFloat(this.value);
    lightIntensityLabel.textContent = intensity.toFixed(1);
    
    // Actualizar TODAS las luces
    if (dirLight) dirLight.intensity = intensity;
    if (hemiLight) hemiLight.intensity = intensity;
    
    // Luz ambiental m谩s suave
    scene.ambientColor = new BABYLON.Color3(0.4, 0.5, 0.7).scale(intensity * 0.8);
});

// NUEVO: Control de sensibilidad del joystick
const joystickSensitivityRange = document.getElementById("joystickSensitivityRange");
const joystickSensitivityLabel = document.getElementById("joystickSensitivityLabel");
let joystickSensitivity = 1.0;

joystickSensitivityRange.addEventListener('input', function() {
    joystickSensitivity = parseFloat(this.value);
    joystickSensitivityLabel.textContent = joystickSensitivity.toFixed(1);
});

// Controles
const maxSpeedRange = document.getElementById("maxSpeedRange");
const accelRange = document.getElementById("accelRange");
const brakeRange = document.getElementById("brakeRange");
const cameraHeightRange = document.getElementById("cameraHeightRange");
const maxSpeedLabel = document.getElementById("maxSpeedLabel");
const accelLabel = document.getElementById("accelLabel");
const brakeLabel = document.getElementById("brakeLabel");
const cameraHeightLabel = document.getElementById("cameraHeightLabel");

// Variables del juego
let maxSpeed = 330;
let targetAccelerationTime = 2.0;
let brakeFriction = 150;
let cameraHeight = 1.0;
let currentCar = 'f1';

// =========================
// SISTEMA DE MARCHAS REALISTA POR COCHE
// =========================
const manualTransmissionToggle = document.getElementById("manualTransmissionToggle");
const gearUpBtn = document.getElementById("gearUp");
const gearDownBtn = document.getElementById("gearDown");
const gearControls = document.getElementById("gearControls");
const rpmFill = document.getElementById("rpmFill");
const rpmValue = document.getElementById("rpmValue");

let isManualTransmission = false;
let currentGear = 0; // 0 = Neutral, 1-8 = Marchas, -1 = Marcha atr谩s
let maxGear = 6;

// Configuraci贸n de marchas espec铆fica para cada coche
const carGearConfigs = {
    'f1': {
        maxGear: 8,
        gearSpeedLimits: {1: 80, 2: 120, 3: 160, 4: 200, 5: 240, 6: 280, 7: 320, 8: 350},
        gearMinSpeeds: {1: 0, 2: 40, 3: 70, 4: 100, 5: 130, 6: 160, 7: 190, 8: 220},
        gearRatios: [0, 4.2, 3.5, 2.8, 2.2, 1.8, 1.4, 1.1, 0.9],
        finalDriveRatio: 3.8,
        redlineRPM: 15000,
        maxRPM: 16000,
        idleRPM: 4000
    },
    'gt3': {
        maxGear: 6,
        gearSpeedLimits: {1: 70, 2: 110, 3: 150, 4: 190, 5: 240, 6: 300},
        gearMinSpeeds: {1: 0, 2: 30, 3: 50, 4: 70, 5: 90, 6: 110},
        gearRatios: [0, 3.8, 2.5, 1.8, 1.3, 1.0, 0.8],
        finalDriveRatio: 3.5,
        redlineRPM: 8500,
        maxRPM: 9000,
        idleRPM: 800
    },
    'gt4': {
        maxGear: 6,
        gearSpeedLimits: {1: 60, 2: 90, 3: 120, 4: 160, 5: 200, 6: 250},
        gearMinSpeeds: {1: 0, 2: 25, 3: 40, 4: 55, 5: 70, 6: 85},
        gearRatios: [0, 3.5, 2.2, 1.6, 1.2, 1.0, 0.85],
        finalDriveRatio: 3.8,
        redlineRPM: 7500,
        maxRPM: 8000,
        idleRPM: 700
    },
    'hypercar': {
        maxGear: 7,
        gearSpeedLimits: {1: 90, 2: 140, 3: 190, 4: 240, 5: 290, 6: 340, 7: 400},
        gearMinSpeeds: {1: 0, 2: 45, 3: 75, 4: 105, 5: 135, 6: 165, 7: 195},
        gearRatios: [0, 3.9, 2.8, 2.0, 1.5, 1.1, 0.9, 0.7],
        finalDriveRatio: 3.2,
        redlineRPM: 11000,
        maxRPM: 12000,
        idleRPM: 900
    },
    'touring': {
        maxGear: 6,
        gearSpeedLimits: {1: 60, 2: 100, 3: 140, 4: 180, 5: 220, 6: 280},
        gearMinSpeeds: {1: 0, 2: 30, 3: 50, 4: 70, 5: 90, 6: 110},
        gearRatios: [0, 3.2, 2.1, 1.5, 1.1, 0.9, 0.75],
        finalDriveRatio: 4.1,
        redlineRPM: 8000,
        maxRPM: 8500,
        idleRPM: 750
    },
    'rally': {
        maxGear: 6,
        gearSpeedLimits: {1: 50, 2: 80, 3: 110, 4: 140, 5: 170, 6: 220},
        gearMinSpeeds: {1: 0, 2: 20, 3: 35, 4: 50, 5: 65, 6: 80},
        gearRatios: [0, 3.9, 2.6, 1.8, 1.3, 1.0, 0.8],
        finalDriveRatio: 4.4,
        redlineRPM: 8200,
        maxRPM: 8500,
        idleRPM: 850
    },
    'drift': {
        maxGear: 6,
        gearSpeedLimits: {1: 55, 2: 85, 3: 115, 4: 145, 5: 175, 6: 240},
        gearMinSpeeds: {1: 0, 2: 25, 3: 40, 4: 55, 5: 70, 6: 85},
        gearRatios: [0, 3.7, 2.4, 1.7, 1.2, 0.95, 0.78],
        finalDriveRatio: 4.2,
        redlineRPM: 7800,
        maxRPM: 8200,
        idleRPM: 800
    }
};

let currentGearConfig = carGearConfigs.f1;

// RPM calculation
let currentRPM = 0;

function getCurrentGearConfig() {
    return carGearConfigs[currentCar];
}

function updateGearConfig() {
    currentGearConfig = getCurrentGearConfig();
    maxGear = currentGearConfig.maxGear;
    
    // Resetear marcha actual si es mayor que las disponibles
    if (currentGear > maxGear) {
        currentGear = maxGear;
        updateGearIndicator();
    }
}

// Toggle transmisi贸n manual/autom谩tica
manualTransmissionToggle.addEventListener('change', () => {
    isManualTransmission = manualTransmissionToggle.checked;
    gearControls.style.display = isManualTransmission ? 'flex' : 'none';
    
    if (isManualTransmission) {
        currentGear = 1; // Empezar en primera
        updateGearIndicator();
    } else {
        currentGear = 0; // Volver a neutral
        updateGearIndicator();
    }
});

// =========================
// BOTONES DE MARCHAS MEJORADOS - CON RESTRICCIONES DE VELOCIDAD
// =========================

// Cambio de marcha hacia arriba - CON RESTRICCIONES
gearUpBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    const currentSpeedKmh = Math.abs(currentSpeed * speedFactor);
    
    if (currentGear === -1) {
        currentGear = 0;
        updateGearIndicator();
    } else if (currentGear === 0) {
        currentGear = 1;
        updateGearIndicator();
    } else if (currentGear < maxGear && currentGear > 0) {
        // Subir de marcha solo si la velocidad es suficiente
        const minSpeedForNextGear = getMinSpeedForGear(currentGear + 1);
        
        if (currentSpeedKmh >= minSpeedForNextGear * 0.8) {
            currentGear++;
            updateGearIndicator();
        }
    }
    
    gearUpBtn.style.transform = 'scale(0.95)';
    setTimeout(() => { gearUpBtn.style.transform = 'scale(1)'; }, 100);
}, { passive: false });

gearUpBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    e.stopPropagation();
}, { passive: false });

// Cambio de marcha hacia abajo - CON RESTRICCIONES
gearDownBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    const currentSpeedKmh = Math.abs(currentSpeed * speedFactor);
    
    if (currentGear > 1) {
        // Bajar de marcha solo si la velocidad no es excesiva
        const maxSpeedForLowerGear = getSpeedLimitForGear(currentGear - 1);
        
        if (currentSpeedKmh <= maxSpeedForLowerGear * 1.2) {
            currentGear--;
            updateGearIndicator();
        }
    } else if (currentGear === 1) {
        currentGear = 0;
        updateGearIndicator();
    } else if (currentGear === 0) {
        // De neutral a marcha atr谩s (solo si casi parado)
        if (currentSpeedKmh < 5) {
            currentGear = -1;
            updateGearIndicator();
        }
    }
    
    gearDownBtn.style.transform = 'scale(0.95)';
    setTimeout(() => { gearDownBtn.style.transform = 'scale(1)'; }, 100);
}, { passive: false });

gearDownBtn.addEventListener('touchend', (e) => {
    e.preventDefault();
    e.stopPropagation();
}, { passive: false });

// Tambi茅n mejorar los event listeners de clic para dispositivos con rat贸n
gearUpBtn.addEventListener('mousedown', () => {
    const currentSpeedKmh = Math.abs(currentSpeed * speedFactor);
    
    if (currentGear === -1) {
        currentGear = 0;
        updateGearIndicator();
    } else if (currentGear === 0) {
        currentGear = 1;
        updateGearIndicator();
    } else if (currentGear < maxGear && currentGear > 0) {
        const minSpeedForNextGear = getMinSpeedForGear(currentGear + 1);
        
        if (currentSpeedKmh >= minSpeedForNextGear * 0.8) {
            currentGear++;
            updateGearIndicator();
        }
    }
    gearUpBtn.style.transform = 'scale(0.95)';
});

gearUpBtn.addEventListener('mouseup', () => {
    gearUpBtn.style.transform = 'scale(1)';
});

gearDownBtn.addEventListener('mousedown', () => {
    const currentSpeedKmh = Math.abs(currentSpeed * speedFactor);
    
    if (currentGear > 1) {
        const maxSpeedForLowerGear = getSpeedLimitForGear(currentGear - 1);
        
        if (currentSpeedKmh <= maxSpeedForLowerGear * 1.2) {
            currentGear--;
            updateGearIndicator();
        }
    } else if (currentGear === 1) {
        currentGear = 0;
        updateGearIndicator();
    } else if (currentGear === 0) {
        if (currentSpeedKmh < 5) {
            currentGear = -1;
            updateGearIndicator();
        }
    }
    gearDownBtn.style.transform = 'scale(0.95)';
});

gearDownBtn.addEventListener('mouseup', () => {
    gearDownBtn.style.transform = 'scale(1)';
});

// Y tambi茅n a帽adir eventos para cuando el toque sale del bot贸n
gearUpBtn.addEventListener('touchcancel', () => {
    gearUpBtn.style.transform = 'scale(1)';
});

gearDownBtn.addEventListener('touchcancel', () => {
    gearDownBtn.style.transform = 'scale(1)';
});

function updateGearIndicator() {
    if (currentGear === 0) {
        gearIndicator.textContent = "N";
    } else if (currentGear === -1) {
        gearIndicator.textContent = "R";
    } else {
        gearIndicator.textContent = currentGear.toString();
    }
}

function calculateRPM(speedKmh, gear) {
    if (gear <= 0) return currentGearConfig.idleRPM;
    
    const config = getCurrentGearConfig();
    const speedMs = speedKmh / 3.6;
    const wheelRPM = (speedMs * 60) / (2 * Math.PI * 0.33); // Radio de rueda ~0.33m
    const engineRPM = wheelRPM * config.gearRatios[gear] * config.finalDriveRatio;
    
    return Math.max(config.idleRPM, Math.min(config.maxRPM, engineRPM));
}

function updateRPMIndicator(rpm) {
    const config = getCurrentGearConfig();
    const rpmPercentage = (rpm - config.idleRPM) / (config.redlineRPM - config.idleRPM) * 100;
    rpmFill.style.width = Math.min(100, rpmPercentage) + '%';
    rpmValue.textContent = Math.round(rpm);
    
    // Cambiar color seg煤n RPM (verde -> amarillo -> rojo)
    if (rpmPercentage < 60) {
        rpmFill.style.background = '#0f0';
    } else if (rpmPercentage < 85) {
        rpmFill.style.background = '#ff0';
    } else {
        rpmFill.style.background = '#f00';
    }
}

function getSpeedLimitForGear(gear) {
    const config = getCurrentGearConfig();
    return config.gearSpeedLimits[gear] || maxSpeed;
}

function getMinSpeedForGear(gear) {
    const config = getCurrentGearConfig();
    return config.gearMinSpeeds[gear] || 0;
}

// =========================
// FSICA AVANZADA
// =========================

// Base de datos de coches
const cars = {
    'f1': { 
        name: 'F贸rmula 1', 
        maxSpeed: 350, 
        acceleration: 1.8, 
        brake: 180,
        weight: 740,
        downforce: 1.8,
        drag: 0.75,
        centerOfMass: 0.4,
        tireGrip: 1.4
    },
    'gt3': { 
        name: 'GT3', 
        maxSpeed: 300, 
        acceleration: 2.5, 
        brake: 160,
        weight: 1250,
        downforce: 1.2,
        drag: 0.85,
        centerOfMass: 0.45,
        tireGrip: 1.2
    },
    'gt4': { 
        name: 'GT4', 
        maxSpeed: 250, 
        acceleration: 3.2, 
        brake: 140,
        weight: 1350,
        downforce: 0.9,
        drag: 0.95,
        centerOfMass: 0.5,
        tireGrip: 1.1
    },
    'hypercar': { 
        name: 'Hypercar', 
        maxSpeed: 400, 
        acceleration: 2.2, 
        brake: 200,
        weight: 1100,
        downforce: 1.6,
        drag: 0.65,
        centerOfMass: 0.42,
        tireGrip: 1.35
    },
    'touring': { 
        name: 'Touring Car', 
        maxSpeed: 280, 
        acceleration: 3.5, 
        brake: 130,
        weight: 1150,
        downforce: 0.7,
        drag: 1.05,
        centerOfMass: 0.52,
        tireGrip: 1.0
    },
    'rally': { 
        name: 'Rally', 
        maxSpeed: 220, 
        acceleration: 4.0, 
        brake: 120,
        weight: 1300,
        downforce: 0.5,
        drag: 1.15,
        centerOfMass: 0.55,
        tireGrip: 0.9
    },
    'drift': { 
        name: 'Drift Car', 
        maxSpeed: 240, 
        acceleration: 3.8, 
        brake: 110,
        weight: 1200,
        downforce: 0.4,
        drag: 1.1,
        centerOfMass: 0.48,
        tireGrip: 0.8
    }
};

// Variables de f铆sica
let carWeight = 740;
let carDownforce = 1.8;
let carDrag = 0.75;
let carCenterOfMass = 0.4;
let carTireGrip = 1.4;

// Funci贸n para calcular aceleraci贸n
function calculateAccelerationFromTime(zeroTo100Time) {
    const targetSpeedMs = 27.78; // 100 km/h en m/s
    return (targetSpeedMs / zeroTo100Time) * 3;
}

let accel = calculateAccelerationFromTime(targetAccelerationTime);

// Funci贸n para cambiar de coche
function changeCar(carType) {
    const car = cars[carType];
    if (!car) return;
    
    currentCar = carType;
    
    // Actualizar valores
    maxSpeed = car.maxSpeed;
    targetAccelerationTime = car.acceleration;
    brakeFriction = car.brake;
    accel = calculateAccelerationFromTime(targetAccelerationTime);
    
    // Actualizar propiedades f铆sicas
    carWeight = car.weight;
    carDownforce = car.downforce;
    carDrag = car.drag;
    carCenterOfMass = car.centerOfMass;
    carTireGrip = car.tireGrip;
    
    // Actualizar configuraci贸n de marchas
    updateGearConfig();
    
    // Actualizar UI
    maxSpeedRange.value = maxSpeed;
    maxSpeedLabel.textContent = maxSpeed;
    
    accelRange.value = targetAccelerationTime;
    accelLabel.textContent = targetAccelerationTime.toFixed(1);
    
    brakeRange.value = brakeFriction;
    brakeLabel.textContent = brakeFriction;
    
    // Actualizar selecci贸n visual
    document.querySelectorAll('.car-option').forEach(option => {
        option.classList.remove('selected');
    });
    document.querySelector(`.car-option[data-car="${carType}"]`).classList.add('selected');
    
    // NUEVO: Actualizar vista en primera persona
    updateCockpitView();
}

// Event listeners para selecci贸n de coches
document.querySelectorAll('.car-option').forEach(option => {
    option.addEventListener('click', () => {
        const carType = option.getAttribute('data-car');
        changeCar(carType);
        carsPanel.style.display = 'none';
    });
});

// Event listeners para los controles
maxSpeedRange.addEventListener('input', () => { 
    maxSpeed = parseInt(maxSpeedRange.value); 
    maxSpeedLabel.textContent = maxSpeed; 
});

accelRange.addEventListener('input', () => { 
    targetAccelerationTime = parseFloat(accelRange.value);
    accel = calculateAccelerationFromTime(targetAccelerationTime);
    accelLabel.textContent = targetAccelerationTime.toFixed(1);
});

brakeRange.addEventListener('input', () => { 
    brakeFriction = parseInt(brakeRange.value); 
    brakeLabel.textContent = brakeFriction; 
});

cameraHeightRange.addEventListener('input', () => { 
    cameraHeight = parseFloat(cameraHeightRange.value);
    cameraHeightLabel.textContent = cameraHeight.toFixed(1);
    if (camera) {
        camera.position.y = cameraHeight;
    }
});

// Clima
const weatherSelect = document.getElementById("weatherSelect");

// M煤sica
const musicBtn = document.getElementById("musicBtn");
const motorAudio = document.getElementById("motorAudio");
let musicOn = true;
musicBtn.addEventListener('click', () => {
    musicOn = !musicOn;
    if (musicOn) motorAudio.play();
    else motorAudio.pause();
    musicBtn.textContent = musicOn ? "On" : "Off";
});

// N煤mero de vueltas
const lapsNumberInput = document.getElementById("lapsNumber");
let totalLaps = parseInt(lapsNumberInput.value);
lapsNumberInput.addEventListener('input', () => { totalLaps = parseInt(lapsNumberInput.value); });

// =========================
// GIROSCOPIO
// =========================
const gyroToggle = document.getElementById("gyroToggle");
const gyroControls = document.getElementById("gyroControls");
const calibrateGyroBtn = document.getElementById("calibrateGyroBtn");
const gyroStatus = document.getElementById("gyroStatus");
const gyroDebug = document.getElementById("gyroDebug");
const gyroIndicator = document.getElementById("gyroIndicator");
const gyroIndicatorBar = document.getElementById("gyroIndicatorBar");
const gyroSensitivityRange = document.getElementById("gyroSensitivityRange");
const gyroMaxRange = document.getElementById("gyroMaxRange");
const gyroSensitivityLabel = document.getElementById("gyroSensitivityLabel");
const gyroMaxLabel = document.getElementById("gyroMaxLabel");
const gyroModeSelect = document.getElementById("gyroModeSelect");
const orientationInfo = document.getElementById("orientationInfo");

let gyroEnabled = false;
let gyroCalibrated = false;
let gyroCalibrationValue = 0;
let gyroRotation = 0;
let gyroAvailable = false;
let gyroSensitivity = 1.0;
let gyroMaxRotation = 1.0;
let currentGyroMode = 'auto';

// Configuraci贸n de sensibilidad
gyroSensitivityRange.addEventListener('input', () => {
    gyroSensitivity = parseFloat(gyroSensitivityRange.value);
    gyroSensitivityLabel.textContent = gyroSensitivity.toFixed(1);
});

gyroMaxRange.addEventListener('input', () => {
    gyroMaxRotation = parseFloat(gyroMaxRange.value);
    gyroMaxLabel.textContent = gyroMaxRotation.toFixed(1);
});

gyroModeSelect.addEventListener('change', () => {
    currentGyroMode = gyroModeSelect.value;
});

// Verificar si el giroscopio est谩 disponible
if (window.DeviceOrientationEvent) {
    gyroAvailable = true;
    gyroStatus.textContent = "Estado: Disponible";
} else {
    gyroStatus.textContent = "Estado: No compatible";
}

// Referencia al joystick para ocultarlo cuando se use giroscopio
const joystickContainer = document.getElementById("joystickContainer");

// Evento para activar/desactivar el giroscopio
gyroToggle.addEventListener('change', () => {
    gyroEnabled = gyroToggle.checked;
    
    if (gyroEnabled) {
        joystickContainer.style.display = 'none';
        document.getElementById('brakeSlider').style.left = '30px';
        document.getElementById('brakeSlider').style.right = 'auto';
        document.querySelector('.pedal-value.brake').style.left = '30px';
        document.querySelector('.pedal-value.brake').style.right = 'auto';

        gyroControls.style.display = 'block';
        gyroIndicator.style.display = 'block';
        orientationInfo.style.display = 'block';
        
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                        gyroStatus.textContent = "Estado: Activado";
                    } else {
                        gyroStatus.textContent = "Estado: Permiso denegado";
                        gyroToggle.checked = false;
                        gyroEnabled = false;
                        joystickContainer.style.display = 'block';
                        resetBrakePosition();
                    }
                })
                .catch(err => {
                    console.error(err);
                    gyroToggle.checked = false;
                    gyroEnabled = false;
                    joystickContainer.style.display = 'block';
                    resetBrakePosition();
                });
        } else {
            window.addEventListener('deviceorientation', handleDeviceOrientation);
            gyroStatus.textContent = "Estado: Activado";
        }
    } else {
        joystickContainer.style.display = 'block';
        resetBrakePosition();

        gyroControls.style.display = 'none';
        gyroIndicator.style.display = 'none';
        orientationInfo.style.display = 'none';
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
        gyroStatus.textContent = "Estado: Desactivado";
        gyroRotation = 0;
    }
});

function resetBrakePosition() {
    const brakeSlider = document.getElementById('brakeSlider');
    const brakeValue = document.querySelector('.pedal-value.brake');
    
    brakeSlider.style.left = 'auto';
    brakeSlider.style.right = '130px';
    brakeValue.style.left = 'auto';
    brakeValue.style.right = '130px';
}

function getSteeringAxis(event) {
    const beta = event.beta;
    const gamma = event.gamma;
    
    let steeringValue;
    
    if (currentGyroMode === 'beta') {
        steeringValue = beta;
    } else if (currentGyroMode === 'gamma') {
        steeringValue = gamma;
    } else {
        const absBeta = Math.abs(beta);
        const absGamma = Math.abs(gamma);
        
        if (absBeta > absGamma) {
            steeringValue = beta;
            orientationInfo.textContent = "Usando Beta (Inclinaci贸n Frontal)";
        } else {
            steeringValue = gamma;
            orientationInfo.textContent = "Usando Gamma (Inclinaci贸n Lateral)";
        }
    }
    
    return steeringValue;
}

function handleDeviceOrientation(event) {
    if (!gyroEnabled) return;
    
    const beta = event.beta;
    const gamma = event.gamma;
    const alpha = event.alpha;
    
    let steeringValue = getSteeringAxis(event);
    
    let normalizedValue = steeringValue / 90;
    
    let adjustedRotation = normalizedValue;
    if (gyroCalibrated) {
        adjustedRotation = normalizedValue - gyroCalibrationValue;
    }
    
    adjustedRotation = adjustedRotation * gyroSensitivity;
    adjustedRotation = Math.max(-gyroMaxRotation, Math.min(gyroMaxRotation, adjustedRotation));
    
    gyroRotation = adjustedRotation;
    
    const indicatorPosition = 50 + (gyroRotation / gyroMaxRotation * 50);
    gyroIndicatorBar.style.width = `${indicatorPosition}%`;
    
    if (gyroRotation > 0.1) {
        gyroIndicatorBar.style.background = '#0f0';
    } else if (gyroRotation < -0.1) {
        gyroIndicatorBar.style.background = '#f00';
    } else {
        gyroIndicatorBar.style.background = '#0ff';
    }
    
    gyroDebug.textContent = `Beta: ${beta?.toFixed(1) || 'N/A'}掳 | Gamma: ${gamma?.toFixed(1) || 'N/A'}掳 | Alpha: ${alpha?.toFixed(1) || 'N/A'}掳 | Rot: ${gyroRotation.toFixed(2)}`;
}

calibrateGyroBtn.addEventListener('click', () => {
    if (!gyroEnabled) return;
    
    gyroStatus.textContent = "Calibrando... Mant茅n el dispositivo en posici贸n neutral";
    
    let samples = [];
    let sampleCount = 0;
    const maxSamples = 30;
    
    const calibrationListener = (event) => {
        if (sampleCount < maxSamples) {
            const steeringValue = getSteeringAxis(event);
            samples.push(steeringValue / 90);
            sampleCount++;
        } else {
            window.removeEventListener('deviceorientation', calibrationListener);
            
            const average = samples.reduce((a, b) => a + b, 0) / samples.length;
            gyroCalibrationValue = average;
            gyroCalibrated = true;
            
            gyroStatus.textContent = "Calibraci贸n completada";
            gyroDebug.textContent = `Calibrado: ${gyroCalibrationValue.toFixed(3)}`;
        }
    };
    
    window.addEventListener('deviceorientation', calibrationListener);
    
    setTimeout(() => {
        window.removeEventListener('deviceorientation', calibrationListener);
        if (!gyroCalibrated && samples.length > 0) {
            const average = samples.reduce((a, b) => a + b, 0) / samples.length;
            gyroCalibrationValue = average;
            gyroCalibrated = true;
            gyroStatus.textContent = "Calibraci贸n completada";
            gyroDebug.textContent = `Calibrado: ${gyroCalibrationValue.toFixed(3)}`;
        }
    }, 3000);
});

// =========================
// Bot贸n Posici贸n Inicial
// =========================
const resetPositionBtn = document.getElementById("resetPositionBtn");
resetPositionBtn.addEventListener("click", resetToStartPosition);

function resetToStartPosition() {
    currentSpeed = 0;
    playerMesh.position.set(-824.16, 42.56, 765.72);
    camera.rotation.y = 0;
    
    // Resetear cron贸metro
    isRacing = false;
    hasCrossedFinishLine = false;
    currentLapStartTime = 0;
    raceStartTime = 0;
    lapCount = 0;
    timerStatus.textContent = "ESPERANDO EN META";
    timerStatus.style.color = "#0ff";
    lapTimes.innerHTML = "";
    
    // Detener y resetear fantasma
    stopGhostRecording();
    removeGhostCar();
    
    // Reparar el coche si est谩 da帽ado
    if (isCarDestroyed) {
        resetAfterCrash();
    }
}

// =========================
// SLIDERS MEJORADOS - TRANSICIN SUAVE
// =========================
let throttlePressure = 0;
let brakePressure = 0;
const throttleFill = document.getElementById('throttleFill');
const brakeFill = document.getElementById('brakeFill');
const throttleValueLabel = document.getElementById('throttleValue');
const brakeValueLabel = document.getElementById('brakeValue');
const gearIndicator = document.getElementById('gearIndicator');

function setupAnalogSlider(slider, fillElement, valueCallback, valueLabel) {
    let active = false;
    let touchId = null;

    slider.addEventListener('touchstart', e => {
        if (active) return;
        
        const touch = e.changedTouches[0];
        active = true;
        touchId = touch.identifier;
        updateSlider(touch);
    }, {passive:false});

    slider.addEventListener('touchmove', e => {
        if (!active) return;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                updateSlider(e.changedTouches[i]);
                break;
            }
        }
    }, {passive:false});

    slider.addEventListener('touchend', e => {
        if (!active) return;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                active = false;
                touchId = null;
                valueCallback(0);
                fillElement.style.height = '0%';
                if (valueLabel) valueLabel.textContent = '0%';
                break;
            }
        }
    });

    slider.addEventListener('touchcancel', e => {
        if (!active) return;
        
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                active = false;
                touchId = null;
                valueCallback(0);
                fillElement.style.height = '0%';
                if (valueLabel) valueLabel.textContent = '0%';
                break;
            }
        }
    });

    function updateSlider(touch) {
        const rect = slider.getBoundingClientRect();
        const relativeY = touch.clientY - rect.top;
        let pressure = 1 - (relativeY / rect.height);
        pressure = Math.max(0, Math.min(1, pressure));
        
        // TRANSICIN SUAVE - sin saltos
        fillElement.style.transition = 'height 0.05s ease-out';
        fillElement.style.height = (pressure * 100) + '%';
        valueCallback(pressure);
        if (valueLabel) valueLabel.textContent = Math.round(pressure*100) + '%';
    }
}

setupAnalogSlider(document.getElementById('throttleSlider'), throttleFill, v => throttlePressure = v, throttleValueLabel);
setupAnalogSlider(document.getElementById('brakeSlider'), brakeFill, v => brakePressure = v, brakeValueLabel);

// =========================
// BabylonJS Juego
// =========================
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.collisionsEnabled = true;

// CIELO EXACTO
const skySphere = BABYLON.MeshBuilder.CreateSphere("skySphere", { 
    diameter: 10000, 
    segments: 64 
}, scene);

// Material con tu imagen
const skyMaterial = new BABYLON.StandardMaterial("skyMaterial", scene);
skyMaterial.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Vc4x5sTq/cielo.jpg", scene);
skyMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1); // Brillante
skyMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
skyMaterial.disableLighting = true; // No afectado por luces
skyMaterial.backFaceCulling = false; // Importante: ver desde dentro

// Invertir la esfera para verla desde dentro
skySphere.material = skyMaterial;
skySphere.infiniteDistance = true;

// Mant茅n tus luces
const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
hemiLight.diffuse = new BABYLON.Color3(0.8, 0.9, 1);
hemiLight.groundColor = new BABYLON.Color3(0.2, 0.4, 0.8);
hemiLight.intensity = 1.2;

const dirLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.5), scene);
dirLight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
dirLight.intensity = 0.8;

scene.ambientColor = new BABYLON.Color3(0.4, 0.5, 0.7);
    
// PLAYER
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", {height: 1.8, radius: 0.3}, scene);
playerMesh.isVisible = false;
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5, 3, 0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0, 2, 0);

// CAMERA
const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, cameraHeight, 0), scene);
camera.parent = playerMesh;
camera.detachControl(canvas);

// UI
const debug = document.getElementById("debug");
const speedBar = document.getElementById("speedBar");

// MOVIMIENTO
let currentSpeed = 0;
let maxReverse = 50;
let airFriction = 8;

// JOYSTICK
const joystickHandle = document.getElementById("joystickHandle");
let isJoystickActive = false;
let joystickRotation = 0;
const rotationSpeed = 1.2;
const minSpeedForSteering = 5;

joystickContainer.addEventListener('touchstart', e => { 
    if (Math.abs(currentSpeed) < minSpeedForSteering) return; 
    e.preventDefault(); 
    isJoystickActive = true; 
    updateJoystick(e.touches[0]); 
});

joystickContainer.addEventListener('touchmove', e => { 
    if (Math.abs(currentSpeed) < minSpeedForSteering) { 
        resetJoystick(); 
        return; 
    } 
    if (!isJoystickActive) return; 
    e.preventDefault(); 
    updateJoystick(e.touches[0]); 
});

joystickContainer.addEventListener('touchend', e => { 
    e.preventDefault(); 
    isJoystickActive = false; 
    resetJoystick(); 
});

function updateJoystick(touch) { 
    const rect = joystickContainer.getBoundingClientRect(); 
    const dx = touch.clientX - (rect.left + rect.width / 2); 
    const maxDist = rect.width / 2 - joystickHandle.offsetWidth / 2; 
    const dist = Math.min(Math.abs(dx), maxDist); 
    joystickHandle.style.transform = `translate(calc(-50% + ${Math.sign(dx) * dist}px), -50%)`; 
    joystickRotation = Math.max(-1, Math.min(1, dx / maxDist)); 
}

function resetJoystick() { 
    joystickHandle.style.transform = 'translate(-50%, -50%)'; 
    joystickRotation = 0; 
}

function updateJoystickState() { 
    if (Math.abs(currentSpeed) >= minSpeedForSteering) {
        joystickContainer.classList.remove('joystick-disabled'); 
    } else { 
        joystickContainer.classList.add('joystick-disabled'); 
        if (isJoystickActive) { 
            resetJoystick(); 
            isJoystickActive = false; 
        }
    }
}

// CRONMETRO
const currentTimer = document.getElementById("currentTimer");
const lapTimes = document.getElementById("lapTimes");
const timerStatus = document.getElementById("timerStatus");
const bestLapDisplay = document.getElementById("bestLapDisplay");

let raceStartTime = 0;
let currentLapStartTime = 0;
let bestLapTime = 0;
let lapCount = 0;
let isRacing = false;
let hasCrossedFinishLine = false;
let prevPosZ = 0;

const finishLine = {
    minX: -824.16,
    maxX: -825.10, 
    z: 765,
    width: 30,
    resetThresholdExtra: 10
};

finishLine.centerX = (finishLine.minX + finishLine.maxX) / 2;
finishLine.resetThreshold = finishLine.width + finishLine.resetThresholdExtra;

function formatTime(ms) {
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    const msr = Math.floor(ms % 1000);
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${msr.toString().padStart(3, '0')}`;
}

function updateTimerDisplay() { 
    currentTimer.textContent = isRacing ? formatTime(Date.now() - currentLapStartTime) : "00:00.000"; 
    bestLapDisplay.textContent = bestLapTime > 0 ? `MEJOR VUELTA: ${formatTime(bestLapTime)}` : "MEJOR VUELTA: --:--.---"; 
}

function registerCross() { 
    if (!isRacing) {
        isRacing = true; 
        raceStartTime = Date.now(); 
        currentLapStartTime = raceStartTime; 
        lapCount = 1; 
        timerStatus.textContent = "VUELTA 1"; 
        timerStatus.style.color = "#0f0"; 
        
        // Iniciar grabaci贸n de fantasma para esta vuelta
        startGhostRecording();
        return;
    } 
    
    const lapTime = Date.now() - currentLapStartTime; 
    
    // Guardar datos de fantasma si es mejor vuelta
    saveGhostDataIfBestLap(lapTime);
    
    if (bestLapTime === 0 || lapTime < bestLapTime) bestLapTime = lapTime; 
    
    const lapEl = document.createElement("div"); 
    lapEl.className = "lap-time"; 
    lapEl.textContent = `Vuelta ${lapCount}: ${formatTime(lapTime)}` + (lapTime === bestLapTime ? " " : ""); 
    if (lapTime === bestLapTime) lapEl.classList.add("best-lap"); 
    lapTimes.insertBefore(lapEl, lapTimes.firstChild); 
    
    lapCount++; 
    currentLapStartTime = Date.now(); 
    
    // Reiniciar fantasma para la siguiente vuelta
    resetGhost();
    
    // Iniciar nueva grabaci贸n para la siguiente vuelta
    startGhostRecording();
    
    if (lapCount > totalLaps) { 
        timerStatus.textContent = "CARRERA COMPLETADA"; 
        isRacing = false; 
        stopGhostRecording();
    } else { 
        timerStatus.textContent = `VUELTA ${lapCount}`; 
    }
}

function checkFinishLine() { 
    const pos = playerMesh.position; 
    const insideX = (pos.x >= finishLine.minX && pos.x <= finishLine.maxX); 
    
    if (insideX) { 
        if (!hasCrossedFinishLine && prevPosZ < finishLine.z && pos.z >= finishLine.z && Math.abs(pos.z - finishLine.z) <= finishLine.width) { 
            hasCrossedFinishLine = true; 
            registerCross(); 
        } else if (!hasCrossedFinishLine && prevPosZ > finishLine.z && pos.z <= finishLine.z && Math.abs(pos.z - finishLine.z) <= finishLine.width) { 
            hasCrossedFinishLine = true; 
            registerCross(); 
        } 
    } 
    
    if (Math.abs(pos.z - finishLine.z) > finishLine.resetThreshold) hasCrossedFinishLine = false; 
    prevPosZ = pos.z; 
}

// CARGAR CIRCUITO LAGUNA SECA
BABYLON.SceneLoader.Append("", "https://www.dropbox.com/scl/fi/k7v8s0fylvyzf7pje8qz7/laguna_seca.glb?rlkey=7a1ncxvhbdv5a5w6iyqc2kgvh&st=yo7oqw0d&dl=0", scene, () => {
    scene.meshes.forEach(m => { 
        if (m !== playerMesh && m !== ghostCar) m.checkCollisions = true; 
    });
    // Posici贸n inicial ajustada para Laguna Seca
    playerMesh.position.set(0, 10, 0); 
    prevPosZ = playerMesh.position.z;
    camera.rotation.y = 0;
    
    // Inicializar sistemas
    initDamageSystem();
    initGhostSystem();
    initLeaderboardSystem();
    initMultiplayerSystem();
    updateCockpitView();
    initRearviewMirror();
    
}, null, (s, msg) => { 
    console.error(msg); 
});




function keepGround() { 
    const ray = new BABYLON.Ray(
        playerMesh.position.add(new BABYLON.Vector3(0, 10, 0)), 
        new BABYLON.Vector3(0, -1, 0), 
        50
    ); 
    const hit = scene.pickWithRay(ray, m => m !== playerMesh && m !== ghostCar); 
    if (hit && hit.hit) playerMesh.position.y = hit.pickedPoint.y + 2; 
}

// CORRECCIN: Ajustar factor de velocidad para sensaci贸n m谩s realista
const maxRealKmH = 330;
const speedFactor = maxRealKmH / maxSpeed * 1.5; // Aumentado para sensaci贸n m谩s r谩pida

// BUCLE PRINCIPAL - FSICA CON SISTEMA DE MARCHAS REALISTA CORREGIDO
engine.runRenderLoop(() => {
    // Clima
    switch(weatherSelect.value) {
        case 'sunny': 
            scene.clearColor = new BABYLON.Color4(0.4, 0.7, 1, 1); 
            break;
        case 'gray': 
            scene.clearColor = new BABYLON.Color4(0.5, 0.5, 0.5, 1); 
            break;
        case 'sunset': 
            scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.2, 1); 
            break;
    }

    const dt = engine.getDeltaTime() / 1000;
    
    // NUEVO: Sincronizar vista F1 con la rotaci贸n de la c谩mara
    if (currentCar === 'f1' && f1CockpitView.style.display !== 'none') {
        const rotation = camera.rotation.y;
        const maxRotation = 20;
        const offsetX = Math.sin(rotation) * maxRotation;
        const tilt = Math.sin(rotation) * 2;
        f1CockpitView.style.transform = `translateX(${offsetX}px) rotate(${tilt}deg)`;
    }
    
    // CALCULAR RPM
    const currentSpeedKmh = Math.abs(currentSpeed * speedFactor);
    currentRPM = calculateRPM(currentSpeedKmh, currentGear);
    updateRPMIndicator(currentRPM);
    
    // OBTENER CONFIGURACIN ACTUAL DE MARCHAS
    const config = getCurrentGearConfig();
    
    // FSICA MEJORADA CON LGICA DE MARCHAS CORREGIDA
    let accelerationForce = accel * throttlePressure;
    let brakingForce = brakeFriction * brakePressure;

    // Si el coche est谩 destruido, reducir la capacidad de control
    if (isCarDestroyed) {
        accelerationForce *= 0.3;
        brakingForce *= 0.5;
        
        // A帽adir efectos de p茅rdida de control
        camera.rotation.y += (Math.random() * 0.1 - 0.05) * dt * 10;
    }

    // L贸gica de movimiento con sistema de marchas REALISTA CORREGIDO
    if (throttlePressure > 0) {
        if (isManualTransmission) {
            if (currentGear === 0) {
                // En neutral, no acelera - SOLO FRICCIN
                if (currentSpeed > 0) {
                    currentSpeed = Math.max(currentSpeed - (airFriction * 2) * dt, 0);
                } else if (currentSpeed < 0) {
                    currentSpeed = Math.min(currentSpeed + (airFriction * 2) * dt, 0);
                }
            } else if (currentGear > 0) {
                // CORRECCIN: En marcha adelante - RESTRINGIR por velocidad m铆nima de la marcha
                const minSpeedForCurrentGear = getMinSpeedForGear(currentGear);
                const maxSpeedForCurrentGear = getSpeedLimitForGear(currentGear);
                
                if (currentSpeedKmh >= minSpeedForCurrentGear) {
                    // Puede acelerar hasta el l铆mite de la marcha actual
                    currentSpeed = Math.min(currentSpeed + accelerationForce * dt, maxSpeedForCurrentGear);
                } else {
                    // Si la velocidad es demasiado baja para la marcha, el motor NO RESPONDE
                    const dragMultiplier = currentGear >= 3 ? 5 : 3;
                    currentSpeed = Math.max(currentSpeed - (airFriction * dragMultiplier) * dt, 0);
                }
            } else if (currentGear === -1) {
                // Marcha atr谩s
                currentSpeed = Math.max(currentSpeed - accelerationForce * dt, -maxReverse);
            }
        } else {
            // Modo autom谩tico - velocidad completa
            currentSpeed = Math.min(currentSpeed + accelerationForce * dt, maxSpeed);
        }
    } 
    else if (brakePressure > 0) {
        // L贸gica de frenado
        if (currentSpeed > 0) {
            currentSpeed = Math.max(currentSpeed - (brakingForce + airFriction) * dt, 0);
        } 
        else if (currentSpeed < 0) {
            currentSpeed = Math.min(currentSpeed + (brakingForce + airFriction) * dt, 0);
        }
    }
    else {
        // Fricci贸n natural
        if (currentSpeed > 0) {
            currentSpeed = Math.max(currentSpeed - airFriction * dt, 0);
        } else if (currentSpeed < 0) {
            currentSpeed = Math.min(currentSpeed + airFriction * dt, 0);
        }
    }

    updateJoystickState();
    
    // CONTROL DE DIRECCIN - CON SENSIBILIDAD AJUSTABLE
    let steeringRotation = 0;
    if (gyroEnabled && Math.abs(currentSpeed) >= minSpeedForSteering) {
        steeringRotation = gyroRotation * rotationSpeed * dt;
    } else if (isJoystickActive && Math.abs(joystickRotation) > 0.1 && Math.abs(currentSpeed) >= minSpeedForSteering) {
        // APLICAR SENSIBILIDAD DEL JOYSTICK
        steeringRotation = joystickRotation * rotationSpeed * joystickSensitivity * dt;
    }
    
    // Si el coche est谩 da帽ado, reducir el control de direcci贸n
    if (carHealth < 50) {
        steeringRotation *= (carHealth / 50);
    }
    
    if (steeringRotation !== 0) {
        camera.rotation.y += steeringRotation;
    }
    
    // SISTEMA AUTOMTICO DE CAMBIO DE MARCHAS
    if (!isManualTransmission && currentGear >= 0) {
        // Cambio autom谩tico basado en RPM
        if (currentRPM > config.redlineRPM * 0.9 && currentGear < maxGear) {
            currentGear++;
            updateGearIndicator();
        } else if (currentRPM < config.redlineRPM * 0.4 && currentGear > 1) {
            currentGear--;
            updateGearIndicator();
        }
        
        // Determinar marcha en autom谩tico para el indicador
        if (currentSpeed > 0) {
            gearIndicator.textContent = currentGear.toString();
        } else if (currentSpeed < 0) {
            gearIndicator.textContent = "R";
        } else {
            gearIndicator.textContent = "N";
        }
    }
    
    // Actualizar barra de velocidad
    speedBar.style.width = (Math.min(Math.abs(currentSpeed) / maxSpeed, 1) * 100) + "%";
    speedBar.style.background = currentSpeed >= 0 ? "#0f0" : "#f00";
    
    // Grabar datos para el fantasma
    recordGhostData();
    
    // Actualizar fantasma
    updateGhostCar();
    
    // Mover el coche
    if (Math.abs(currentSpeed) > 0.001) { 
        const yaw = camera.rotation.y; 
        const forward = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw)); 
        playerMesh.moveWithCollisions(forward.scale(currentSpeed * speedFactor * dt)); 
    }
    
    // Verificar colisiones
    checkCollisions();
    
    checkFinishLine(); 
    updateTimerDisplay(); 
    keepGround();
    
    // Actualizar indicador de velocidad num茅rico
    document.getElementById('speedNumber').textContent = Math.abs(currentSpeed).toFixed(0) + ' km/h';
    
    scene.render();
});

window.addEventListener('resize', () => engine.resize());

// Inicializar el coche por defecto
changeCar('f1');
</script>
</body>
</html>
