<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Recorrido Circuito SPA - Primera Persona con Colisiones</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnForward{right:100px} #btnBackward{right:180px}
  #speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #speedBar{height:100%;width:0%;background:#0f0;transition:width .3s}
  #debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito SPA...</div>
<div class="button" id="btnForward"></div>
<div class="button" id="btnBackward"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;

// HABILITAR COLISIONES GLOBALES
scene.collisionsEnabled = true;
scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

// Crear un mesh invisible para el jugador con colisiones
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", {
  height: 1.8,
  radius: 0.3
}, scene);
playerMesh.isVisible = false; // Hacerlo invisible
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5, 0.9, 0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0);

// Cámara en primera persona unida al mesh del jugador
const camera = new BABYLON.FreeCamera("fpCamera", new BABYLON.Vector3(0, 0, 0), scene);
camera.parent = playerMesh;
camera.rotation = new BABYLON.Vector3(0, 0, 0);
camera.position = new BABYLON.Vector3(0, 0.9, 0); // A la altura de los ojos

// Configurar controles de la cámara
camera.attachControl(canvas, true);
camera.inputs.attached.mousewheel?.detachControl(canvas);
camera.checkCollisions = false; // La cámara no hace colisiones, el mesh sí
camera.applyGravity = false; // El mesh aplica gravedad
camera.speed = 0;
camera.angularSensibility = 2000;
camera.minZ = 0.1;

// Luz ambiental
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
light.intensity = 0.8;

// Luz direccional adicional
const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
dirLight.intensity = 0.5;

// Variables de movimiento
let moveForward = false;
let moveBackward = false;
let currentSpeed = 0;
const maxSpeed = 0.5;
const acceleration = 0.02;
const friction = 0.03;

const speedBar = document.getElementById("speedBar");
const debug = document.getElementById("debug");

function updateSpeedBar(){
  const porcentaje = Math.min((Math.abs(currentSpeed) / maxSpeed) * 100, 100);
  speedBar.style.width = porcentaje + "%";
  
  if (currentSpeed > 0) {
    speedBar.style.background = "#0f0"; // Verde para adelante
  } else if (currentSpeed < 0) {
    speedBar.style.background = "#f00"; // Rojo para atrás
  } else {
    speedBar.style.background = "#888"; // Gris para parado
  }
}

// Controles de joystick
let joyX=0, joyY=0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position:{left:"75px",bottom:"75px"},
  size:120, color:"white"
});
joystick.on("move", (_,d)=>{ 
  joyX = d.vector.x; 
  joyY = d.vector.y;
});
joystick.on("end", ()=>{ 
  joyX = 0; 
  joyY = 0;
});

// Cargar el circuito SPA
BABYLON.SceneLoader.Append("", "spa.glb", scene, (scene) => {
  console.log("Circuito SPA cargado, meshes:", scene.meshes.length);
  
  // Configurar TODOS los meshes del circuito con colisiones
  scene.meshes.forEach(mesh => {
    if (mesh !== playerMesh) { // No configurar colisiones para el jugador
      mesh.checkCollisions = true;
      
      // Para meshes complejos, asegurar que tengan impostor de colisión
      if (!mesh.physicsImpostor) {
        // Crear impostor de colisión para mesh estático
        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(
          mesh, 
          BABYLON.PhysicsImpostor.MeshImpostor, 
          { mass: 0, restitution: 0.1 }, 
          scene
        );
      }
    }
  });
  
  // Posición por defecto en línea de meta
  playerMesh.position.x = -3780;
  playerMesh.position.z = -3980;
  playerMesh.position.y = 330;
  
  console.log("Jugador posicionado en línea de meta:", playerMesh.position.toString());
  
  // Aplicar gravedad al jugador
  playerMesh.physicsImpostor = new BABYLON.PhysicsImpostor(
    playerMesh,
    BABYLON.PhysicsImpostor.CapsuleImpostor,
    { mass: 1, friction: 0.1, restitution: 0.1 },
    scene
  );
  
  // Verificar que el jugador esté sobre el circuito
  checkPlayerOnGround();
  
  debug.textContent = "Circuito cargado - Línea de meta - Colisiones ACTIVAS";
  
}, null, (scene, message) => {
  console.error("Error cargando spa.glb:", message);
  debug.textContent = "Error cargando spa.glb: " + message;
});

function checkPlayerOnGround() {
  // Lanzar rayo hacia abajo para verificar posición
  const ray = new BABYLON.Ray(
    playerMesh.position.add(new BABYLON.Vector3(0, 10, 0)),
    new BABYLON.Vector3(0, -1, 0),
    50
  );
  
  const hit = scene.pickWithRay(ray, (mesh) => mesh !== playerMesh);
  
  if (hit && hit.hit) {
    console.log("Jugador sobre el circuito a altura:", hit.pickedPoint.y);
    playerMesh.position.y = hit.pickedPoint.y + 1.8;
  } else {
    console.log("No se detectó suelo debajo del jugador");
  }
}

// Controles de movimiento
document.getElementById("btnForward").onclick = function() {
  moveForward = true;
};
document.getElementById("btnForward").addEventListener("touchstart", function() {
  moveForward = true;
});
document.getElementById("btnForward").addEventListener("touchend", function() {
  moveForward = false;
});

document.getElementById("btnBackward").onclick = function() {
  moveBackward = true;
};
document.getElementById("btnBackward").addEventListener("touchstart", function() {
  moveBackward = true;
});
document.getElementById("btnBackward").addEventListener("touchend", function() {
  moveBackward = false;
});

// Teclado para debugging
window.addEventListener("keydown", (e) => {
  if (e.key === 'w' || e.key === 'ArrowUp') moveForward = true;
  if (e.key === 's' || e.key === 'ArrowDown') moveBackward = true;
});

window.addEventListener("keyup", (e) => {
  if (e.key === 'w' || e.key === 'ArrowUp') moveForward = false;
  if (e.key === 's' || e.key === 'ArrowDown') moveBackward = false;
});

// Bucle principal del juego
engine.runRenderLoop(()=>{
  // Control de velocidad
  if (moveForward) {
    currentSpeed = Math.min(currentSpeed + acceleration, maxSpeed);
  } else if (moveBackward) {
    currentSpeed = Math.max(currentSpeed - acceleration, -maxSpeed * 0.7);
  } else {
    // Fricción
    if (currentSpeed > 0) {
      currentSpeed = Math.max(currentSpeed - friction, 0);
    } else if (currentSpeed < 0) {
      currentSpeed = Math.min(currentSpeed + friction, 0);
    }
  }
  
  // MOVIMIENTO CON COLISIONES usando moveWithCollisions
  if (Math.abs(currentSpeed) > 0.01) {
    const direction = new BABYLON.Vector3(
      Math.sin(camera.rotation.y),
      0,
      Math.cos(camera.rotation.y)
    );
    
    // Mover el MESH del jugador (no la cámara) con colisiones
    playerMesh.moveWithCollisions(direction.scale(currentSpeed));
  }
  
  // Movimiento con joystick (también con colisiones)
  if (Math.abs(joyX) > 0.1 || Math.abs(joyY) > 0.1) {
    // Rotación de la cámara con joystick horizontal
    camera.rotation.y -= joyX * 0.03;
    
    // Movimiento con joystick vertical
    const moveSpeed = joyY * 0.15;
    if (Math.abs(moveSpeed) > 0.01) {
      const direction = new BABYLON.Vector3(
        Math.sin(camera.rotation.y),
        0,
        Math.cos(camera.rotation.y)
      );
      
      // Mover el MESH del jugador con colisiones
      playerMesh.moveWithCollisions(direction.scale(moveSpeed));
    }
  }
  
  // Mantener al jugador sobre el suelo
  keepPlayerOnGround();
  
  // Actualizar UI y debug
  updateSpeedBar();
  debug.textContent = `Pos: ${playerMesh.position.x.toFixed(0)}, ${playerMesh.position.y.toFixed(0)}, ${playerMesh.position.z.toFixed(0)} | Vel: ${(currentSpeed * 100).toFixed(0)} | Colisiones: ACTIVAS`;
  
  scene.render();
});

function keepPlayerOnGround() {
  // Lanzar rayos alrededor del jugador para mantenerlo sobre el circuito
  const rayOrigins = [
    new BABYLON.Vector3(0, 1, 0),
    new BABYLON.Vector3(0.5, 1, 0),
    new BABYLON.Vector3(-0.5, 1, 0),
    new BABYLON.Vector3(0, 1, 0.5),
    new BABYLON.Vector3(0, 1, -0.5)
  ];
  
  let groundHeight = null;
  
  rayOrigins.forEach(offset => {
    const rayOrigin = playerMesh.position.add(offset);
    const ray = new BABYLON.Ray(rayOrigin, new BABYLON.Vector3(0, -1, 0), 10);
    const hit = scene.pickWithRay(ray, (mesh) => mesh !== playerMesh);
    
    if (hit && hit.hit) {
      if (groundHeight === null || hit.pickedPoint.y > groundHeight) {
        groundHeight = hit.pickedPoint.y;
      }
    }
  });
  
  // Ajustar altura del jugador si está muy lejos del suelo
  if (groundHeight !== null) {
    const targetHeight = groundHeight + 1.8;
    if (Math.abs(playerMesh.position.y - targetHeight) > 0.5) {
      playerMesh.position.y = targetHeight;
    }
  }
}

window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>