<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>SPA - Control por Vista (Touch Look) - Solo Horizontal</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  html,body{margin:0;overflow:hidden;background:#000;height:100%}
  #renderCanvas{width:100%;height:100%}
  .button{position:absolute;bottom:30px;width:80px;height:80px;background:rgba(255,255,255,0.25);border-radius:50%;pointer-events:auto;}
  #btnForward{right:40px}
  #btnBackward{right:140px}
  #speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
  #debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito...</div>
<div class="button" id="btnForward" title="Acelerar"></div>
<div class="button" id="btnBackward" title="Freno / marcha atrás"></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// SOLO MÓVIL
if (!/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    // No forzar alert para pruebas en escritorio, pero puedes descomentar la línea siguiente
    // alert("Esta aplicación está pensada para móvil.");
}

// Bloquear orientación a landscape si es posible
if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock("landscape").catch(()=>{});
}

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.collisionsEnabled = true;

// PLAYER
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", {height:1.8, radius:0.3}, scene);
playerMesh.isVisible = false;
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5,0.9,0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0,0.9,0);

// CÁMARA
const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0,2,0), scene);
camera.parent = playerMesh;
camera.checkCollisions = false;
camera.applyGravity = false;
// NO limpiar inputs para permitir touch look
camera.attachControl(canvas, true); // habilita rotación con touch
// Desactivar zoom por rueda si alguna vez se usa
if (camera.inputs && camera.inputs.attached && camera.inputs.attached.mousewheel) {
  camera.inputs.attached.mousewheel.detachControl(canvas);
}

// Luces
new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

// UI
const debug = document.getElementById("debug");
const speedBar = document.getElementById("speedBar");

// MOVIMIENTO: botones táctiles (adelante/atrás)
let moveForward=false, moveBackward=false;
let currentSpeed=0;
const maxSpeed=86.4;      // ajustar según quieras (m/s)
const maxReverseSpeed=8;
const accel=30;         // m/s^2
const airFriction=8;

const btnF=document.getElementById("btnForward");
const btnB=document.getElementById("btnBackward");
btnF.addEventListener("touchstart",(e)=>{ e.preventDefault(); moveForward=true; });
btnF.addEventListener("touchend",(e)=>{ e.preventDefault(); moveForward=false; });
btnB.addEventListener("touchstart",(e)=>{ e.preventDefault(); moveBackward=true; });
btnB.addEventListener("touchend",(e)=>{ e.preventDefault(); moveBackward=false; });

// Cargar circuito
BABYLON.SceneLoader.Append("", "spa.glb", scene, ()=>{
    scene.meshes.forEach(m=>{ if(m!==playerMesh) m.checkCollisions=true; });
    playerMesh.position.set(-3780,330,-3980);
    debug.textContent = "Circuito cargado - Usa la vista para orientar y botones para avanzar";
}, null, (s,msg)=>{ console.error(msg); debug.textContent = 'Error cargando spa.glb'; });

// Mantener en suelo
function keepGround(){
  const ray=new BABYLON.Ray(playerMesh.position.add(new BABYLON.Vector3(0,10,0)), new BABYLON.Vector3(0,-1,0), 50);
  const hit=scene.pickWithRay(ray, m=>m!==playerMesh);
  if(hit && hit.hit) playerMesh.position.y = hit.pickedPoint.y + 1.8;
}

// LOOP principal (usamos solo yaw de la cámara - rotación y)
engine.runRenderLoop(()=>{
  const dt = engine.getDeltaTime()/1000;

  // ACELERACIÓN / FRENO
  if(moveForward && !moveBackward) currentSpeed = Math.min(currentSpeed + accel*dt, maxSpeed);
  else if(moveBackward && !moveForward) currentSpeed = Math.max(currentSpeed - accel*dt, -maxReverseSpeed);
  else {
    if(currentSpeed > 0) currentSpeed = Math.max(currentSpeed - airFriction*dt, 0);
    else if(currentSpeed < 0) currentSpeed = Math.min(currentSpeed + airFriction*dt, 0);
  }

  // Actualizar barra
  speedBar.style.width = (Math.min(Math.abs(currentSpeed) / maxSpeed, 1) * 100) + "%";
  speedBar.style.background = currentSpeed >= 0 ? "#0f0" : "#f00";

  // Desplazamiento: usar SOLO yaw (rotación Y) de la cámara; ignorar pitch
  if(Math.abs(currentSpeed) > 0.001){
    const yaw = camera.rotation.y;
    const forward = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    playerMesh.moveWithCollisions(forward.scale(currentSpeed * dt));
  }

  // Mantener en suelo y render
  keepGround();
  debug.textContent = `Pos: ${playerMesh.position.x.toFixed(1)}, ${playerMesh.position.y.toFixed(1)}, ${playerMesh.position.z.toFixed(1)} | Yaw: ${(camera.rotation.y*180/Math.PI).toFixed(1)}° | Vel: ${currentSpeed.toFixed(2)} m/s`;
  scene.render();
});

window.addEventListener('resize', ()=>engine.resize());
</script>
</body>
</html>
