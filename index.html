<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Recorrido Circuito SPA - Primera Persona</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnForward{right:100px} #btnBackward{right:180px}
  #speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #speedBar{height:100%;width:0%;background:#0f0;transition:width .3s}
  #debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito SPA...</div>
<div class="button" id="btnForward"></div>
<div class="button" id="btnBackward"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;
scene.collisionsEnabled = true;
scene.gravity = new BABYLON.Vector3(0,-9.81,0);

// Cámara en primera persona
const camera = new BABYLON.FreeCamera("fpCamera", new BABYLON.Vector3(0, 2, 0), scene);
camera.attachControl(canvas,true);
camera.inputs.attached.mousewheel?.detachControl(canvas);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
camera.ellipsoidOffset = new BABYLON.Vector3(0, 1, 0);
camera.minZ = 0.1;
camera.speed = 0.3;
camera.angularSensibility = 2000;

// Luz ambiental
const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
light.intensity = 0.8;

// Luz direccional adicional
const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
dirLight.intensity = 0.5;

// Variables de movimiento
let moveForward = false;
let moveBackward = false;
let currentSpeed = 0;
const maxSpeed = 2;
const acceleration = 0.01;
const friction = 0.02;

const speedBar = document.getElementById("speedBar");
const debug = document.getElementById("debug");

function updateSpeedBar(){
  const porcentaje = Math.min((Math.abs(currentSpeed) / maxSpeed) * 100, 100);
  speedBar.style.width = porcentaje + "%";
  
  if (currentSpeed > 0) {
    speedBar.style.background = "#0f0"; // Verde para adelante
  } else if (currentSpeed < 0) {
    speedBar.style.background = "#f00"; // Rojo para atrás
  } else {
    speedBar.style.background = "#888"; // Gris para parado
  }
}

// Controles de joystick
let joyX=0, joyY=0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position:{left:"75px",bottom:"75px"},
  size:120, color:"white"
});
joystick.on("move", (_,d)=>{ 
  joyX = d.vector.x; 
  joyY = d.vector.y;
});
joystick.on("end", ()=>{ 
  joyX = 0; 
  joyY = 0;
});

// Cargar el circuito SPA
BABYLON.SceneLoader.Append("", "spa.glb", scene, (scene) => {
  console.log("Circuito SPA cargado, meshes:", scene.meshes.length);
  
  let circuitMesh = null;
  let groundMesh = null;
  
  // Configurar todos los meshes del circuito
  scene.meshes.forEach(mesh => {
    console.log("Mesh:", mesh.name);
    
    // Identificar el circuito principal
    if (mesh.name && (mesh.name.toLowerCase().includes("circuit") || 
                     mesh.name.toLowerCase().includes("track") || 
                     mesh.name.toLowerCase().includes("spa") || 
                     mesh.name.toLowerCase().includes("road") ||
                     mesh.name.toLowerCase().includes("pista") ||
                     mesh.name.toLowerCase().includes("ground"))) {
      circuitMesh = mesh;
      console.log("Circuito identificado:", mesh.name);
    }
    
    // Configurar colisiones para todos los meshes
    mesh.checkCollisions = true;
    
    // Si el mesh parece ser el suelo/circuito, configurarlo como terreno
    if (mesh.getTotalVertices() > 100) { // Mesh complejo, probablemente el circuito
      groundMesh = mesh;
    }
  });
  
  // Si no encontramos un mesh específico, usar el mesh más grande
  if (!circuitMesh && scene.meshes.length > 0) {
    let largestMesh = scene.meshes[0];
    let largestSize = 0;
    
    scene.meshes.forEach(mesh => {
      const boundingInfo = mesh.getBoundingInfo();
      const size = boundingInfo.boundingBox.maximum.subtract(boundingInfo.boundingBox.minimum);
      const volume = size.x * size.y * size.z;
      
      if (volume > largestSize) {
        largestSize = volume;
        largestMesh = mesh;
      }
    });
    
    circuitMesh = largestMesh;
    console.log("Usando mesh más grande como circuito:", circuitMesh.name);
  }
  
  // Posicionar la cámara sobre el circuito
  positionCameraOnTrack();
  
  debug.textContent = "Circuito SPA cargado - Usa joystick para moverte";
  
}, null, (scene, message) => {
  console.error("Error cargando spa.glb:", message);
  debug.textContent = "Error cargando spa.glb: " + message;
});

function positionCameraOnTrack() {
  console.log("Posicionando cámara sobre la pista...");
  
  // Lanzar rayos para encontrar una posición buena en el circuito
  const rayOrigins = [
    new BABYLON.Vector3(0, 100, 0),
    new BABYLON.Vector3(10, 100, 0),
    new BABYLON.Vector3(-10, 100, 0),
    new BABYLON.Vector3(0, 100, 10),
    new BABYLON.Vector3(0, 100, -10)
  ];
  
  let bestPosition = null;
  let maxHeight = -Infinity;
  
  rayOrigins.forEach(origin => {
    const ray = new BABYLON.Ray(origin, new BABYLON.Vector3(0, -1, 0), 200);
    const hit = scene.pickWithRay(ray);
    
    if (hit && hit.hit && hit.pickedPoint.y > maxHeight) {
      maxHeight = hit.pickedPoint.y;
      bestPosition = hit.pickedPoint.clone();
    }
  });
  
  if (bestPosition) {
    // Posicionar la cámara sobre el punto más alto encontrado
    camera.position.x = bestPosition.x;
    camera.position.y = bestPosition.y + 1.7; // Altura de persona
    camera.position.z = bestPosition.z;
    
    // Mirar hacia adelante
    camera.setTarget(new BABYLON.Vector3(bestPosition.x, bestPosition.y + 1.7, bestPosition.z + 10));
    
    console.log("Cámara posicionada en:", camera.position.toString());
    debug.textContent = `Posición: ${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
  } else {
    // Posición por defecto
    camera.position.x = -3800;
    camera.position.z = -3600;
    camera.position.y = 200;
    console.log("Usando posición por defecto");
  }
}

// Controles de movimiento
document.getElementById("btnForward").onclick = function() {
  moveForward = true;
};
document.getElementById("btnForward").addEventListener("touchstart", function() {
  moveForward = true;
});
document.getElementById("btnForward").addEventListener("touchend", function() {
  moveForward = false;
});

document.getElementById("btnBackward").onclick = function() {
  moveBackward = true;
};
document.getElementById("btnBackward").addEventListener("touchstart", function() {
  moveBackward = true;
});
document.getElementById("btnBackward").addEventListener("touchend", function() {
  moveBackward = false;
});

// Teclado para debugging
window.addEventListener("keydown", (e) => {
  if (e.key === 'w' || e.key === 'ArrowUp') moveForward = true;
  if (e.key === 's' || e.key === 'ArrowDown') moveBackward = true;
});

window.addEventListener("keyup", (e) => {
  if (e.key === 'w' || e.key === 'ArrowUp') moveForward = false;
  if (e.key === 's' || e.key === 'ArrowDown') moveBackward = false;
});

// Bucle principal del juego
engine.runRenderLoop(()=>{
  // Control de velocidad
  if (moveForward) {
    currentSpeed = Math.min(currentSpeed + acceleration, maxSpeed);
  } else if (moveBackward) {
    currentSpeed = Math.max(currentSpeed - acceleration, -maxSpeed * 0.5);
  } else {
    // Fricción
    if (currentSpeed > 0) {
      currentSpeed = Math.max(currentSpeed - friction, 0);
    } else if (currentSpeed < 0) {
      currentSpeed = Math.min(currentSpeed + friction, 0);
    }
  }
  
  // Movimiento con joystick
  if (Math.abs(joyX) > 0.1 || Math.abs(joyY) > 0.1) {
    // Rotación con joystick horizontal
    camera.rotation.y -= joyX * 0.03;
    
    // Movimiento con joystick vertical
    const moveSpeed = joyY * 0.1;
    if (Math.abs(moveSpeed) > 0.01) {
      const direction = new BABYLON.Vector3(
        Math.sin(camera.rotation.y),
        0,
        Math.cos(camera.rotation.y)
      );
      camera.position.addInPlace(direction.scale(moveSpeed));
    }
  }
  
  // Movimiento con botones/teclado
  if (Math.abs(currentSpeed) > 0.01) {
    const direction = camera.getDirection(BABYLON.Axis.Z);
    direction.y = 0; // Mantener movimiento horizontal
    direction.normalize();
    
    camera.position.addInPlace(direction.scale(currentSpeed));
  }
  
  // Actualizar UI y debug
  updateSpeedBar();
  debug.textContent = `Pos: ${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)} | Vel: ${(currentSpeed * 100).toFixed(0)}`;
  
  scene.render();
});

window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
