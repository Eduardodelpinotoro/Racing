<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Recorrido Circuito SPA - Movimiento corregido</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnForward{right:100px} #btnBackward{right:180px}
  #speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
  #debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito...</div>
<div class="button" id="btnForward" title="Acelerar"></div>
<div class="button" id="btnBackward" title="Freno / marcha atrás"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;
scene.collisionsEnabled = true;

// PLAYER MESH (sin physics impostor)
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", { height: 1.8, radius: 0.3 }, scene);
playerMesh.isVisible = false;
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5, 0.9, 0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0);

// Cámara en primera persona, parent al mesh
const camera = new BABYLON.FreeCamera("fpCamera", new BABYLON.Vector3(0, 2, 0), scene);
camera.parent = playerMesh;
camera.rotation = new BABYLON.Vector3(0, 0, 0);
camera.checkCollisions = false;
camera.applyGravity = false;
camera.speed = 0;
camera.angularSensibility = 2000;
camera.minZ = 0.1;

// Habilitar control de ratón/táctil para girar la cámara
camera.attachControl(canvas, true);
// Desactivar rueda de scroll para zoom accidental (opcional)
if (camera.inputs && camera.inputs.attached && camera.inputs.attached.mousewheel) {
  camera.inputs.attached.mousewheel.detachControl(canvas);
}

// Luces
new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

// UI
const debug = document.getElementById("debug");
const speedBar = document.getElementById("speedBar");

// Joystick (solo para strafing horizontal)
let joyX = 0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position:{left:"75px",bottom:"75px"},
  size:120, color:"white"
});
joystick.on("move", (_, d) => { joyX = d.vector.x; });
joystick.on("end", () => { joyX = 0; });

// Cargar modelo del circuito (sin físicas, solo collisions)
BABYLON.SceneLoader.Append("", "spa.glb", scene, (s) => {
  s.meshes.forEach(m => {
    if (m !== playerMesh) m.checkCollisions = true;
  });
  // posición por defecto
  playerMesh.position.set(-3780, 330, -3980);
  debug.textContent = "Circuito cargado - listo";
}, null, (scene, message) => {
  console.error(message);
  debug.textContent = "Error cargando spa.glb: " + message;
});

// Mantener jugador pegado al suelo (simple raycast)
function keepPlayerOnGround() {
  const ray = new BABYLON.Ray(playerMesh.position.add(new BABYLON.Vector3(0, 10, 0)), new BABYLON.Vector3(0, -1, 0), 50);
  const hit = scene.pickWithRay(ray, (m)=> m !== playerMesh);
  if (hit && hit.hit) playerMesh.position.y = hit.pickedPoint.y + 1.8;
}

// MOVIMIENTO (acelerador / freno / teclado)
let moveForward = false, moveBackward = false;
let currentSpeed = 0; // unidades por segundo
const maxSpeed = 6.0;            // m/s hacia adelante
const maxReverseSpeed = 3.0;     // m/s hacia atrás
const accel = 8.0;               // m/s^2 (aceleración)
const decel = 10.0;              // m/s^2 (freno)
const airFriction = 6.0;         // desaceleración pasiva cuando no se pulsa nada

// Botones: adaptar para mouse y touch
const btnF = document.getElementById("btnForward");
const btnB = document.getElementById("btnBackward");

function setForward(val){ moveForward = val; }
function setBackward(val){ moveBackward = val; }

["mousedown","touchstart"].forEach(e => btnF.addEventListener(e, ()=> setForward(true)));
["mouseup","mouseleave","touchend","touchcancel"].forEach(e => btnF.addEventListener(e, ()=> setForward(false)));

["mousedown","touchstart"].forEach(e => btnB.addEventListener(e, ()=> setBackward(true)));
["mouseup","mouseleave","touchend","touchcancel"].forEach(e => btnB.addEventListener(e, ()=> setBackward(false)));

// Teclado (W,S / flechas)
window.addEventListener("keydown", (ev) => {
  if (ev.key === 'w' || ev.key === 'ArrowUp') setForward(true);
  if (ev.key === 's' || ev.key === 'ArrowDown') setBackward(true);
});
window.addEventListener("keyup", (ev) => {
  if (ev.key === 'w' || ev.key === 'ArrowUp') setForward(false);
  if (ev.key === 's' || ev.key === 'ArrowDown') setBackward(false);
});

// Animación principal con delta time
engine.runRenderLoop(() => {
  const dt = engine.getDeltaTime() / 1000; // segundos desde el último frame

  // ----- ACELERACIÓN / FRENO -----
  if (moveForward && !moveBackward) {
    currentSpeed = Math.min(currentSpeed + accel * dt, maxSpeed);
  } else if (moveBackward && !moveForward) {
    currentSpeed = Math.max(currentSpeed - accel * dt, -maxReverseSpeed);
  } else {
    // sin input: desacelerar suavemente hacia 0
    if (currentSpeed > 0) {
      currentSpeed = Math.max(currentSpeed - airFriction * dt, 0);
    } else if (currentSpeed < 0) {
      currentSpeed = Math.min(currentSpeed + airFriction * dt, 0);
    }
  }

  // Actualizar barra de velocidad
  const pct = Math.min(Math.abs(currentSpeed) / maxSpeed * 100, 100);
  speedBar.style.width = pct + "%";
  speedBar.style.background = currentSpeed >= 0 ? "#0f0" : "#f00";

  // ----- MOVIMIENTO HACIA ADELANTE/ATRÁS (según orientación de la cámara) -----
  if (Math.abs(currentSpeed) > 0.001) {
    const forward = new BABYLON.Vector3(Math.sin(camera.rotation.y), 0, Math.cos(camera.rotation.y));
    // mover usando velocidad (m/s) * dt -> desplazamiento en metros/frame
    playerMesh.moveWithCollisions(forward.scale(currentSpeed * dt));
  }

  // ----- STRAFING HORIZONTAL (joystick) -----
  if (Math.abs(joyX) > 0.05) {
    const strafeSpeed = -joyX * 3.0; // invertido (negativo para que joystick izquierda => izquierda)
    const right = new BABYLON.Vector3(Math.cos(camera.rotation.y), 0, -Math.sin(camera.rotation.y));
    // movemos directamente sin acumular velocidad (es inmediato)
    playerMesh.moveWithCollisions(right.scale(strafeSpeed * dt));
  }

  // Mantener en suelo y renderizar
  keepPlayerOnGround();

  debug.textContent = `Pos: ${playerMesh.position.x.toFixed(1)}, ${playerMesh.position.y.toFixed(1)}, ${playerMesh.position.z.toFixed(1)} | Vel: ${currentSpeed.toFixed(2)} m/s`;

  scene.render();
});

window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
