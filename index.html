<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>SPA - Control por Vista (Touch Look) - Con Cronómetro Corregido</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
  html,body{margin:0;overflow:hidden;background:#000;height:100%}
  #renderCanvas{width:100%;height:100%}
  .button{position:absolute;bottom:30px;width:80px;height:80px;background:rgba(255,255,255,0.25);border-radius:50%;pointer-events:auto;}
  #btnForward{right:40px}
  #btnBackward{right:140px}
  #speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
  #debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
  
  /* Estilos para el joystick */
  #joystickContainer {
    position: absolute;
    bottom: 30px;
    left: 30px;
    width: 120px;
    height: 120px;
    pointer-events: auto;
    z-index: 10;
  }
  
  #joystickBase {
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.3);
  }
  
  #joystickHandle {
    position: absolute;
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.4);
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    transition: transform 0.05s;
  }
  
  #joystickAxis {
    position: absolute;
    width: 100%;
    height: 4px;
    background: rgba(255, 255, 255, 0.2);
    top: 50%;
    left: 0;
    transform: translateY(-50%);
  }
  
  /* Indicador de joystick desactivado */
  .joystick-disabled {
    opacity: 0.5;
    pointer-events: none;
  }
  
  /* Panel de cronómetro */
  #timerPanel {
    position: absolute;
    top: 70px;
    right: 10px;
    width: 200px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #fff;
    border-radius: 10px;
    padding: 10px;
    color: #fff;
    font-family: monospace;
    z-index: 10;
  }
  
  #currentTimer {
    font-size: 24px;
    text-align: center;
    margin-bottom: 10px;
    color: #0f0;
  }
  
  #lapTimes {
    font-size: 12px;
    max-height: 150px;
    overflow-y: auto;
  }
  
  .lap-time {
    padding: 2px 0;
    border-bottom: 1px solid #444;
  }
  
  .lap-time:last-child {
    border-bottom: none;
  }
  
  .best-lap {
    color: #ff0;
    font-weight: bold;
  }
  
  #timerStatus {
    text-align: center;
    font-size: 14px;
    margin-top: 5px;
    color: #0ff;
  }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito...</div>
<div class="button" id="btnForward" title="Acelerar"></div>
<div class="button" id="btnBackward" title="Freno / marcha atrás"></div>

<!-- Joystick para rotación horizontal -->
<div id="joystickContainer" class="joystick-disabled">
  <div id="joystickBase">
    <div id="joystickAxis"></div>
    <div id="joystickHandle"></div>
  </div>
</div>

<!-- Panel de cronómetro -->
<div id="timerPanel">
  <div id="currentTimer">00:00.000</div>
  <div id="lapTimes"></div>
  <div id="timerStatus">ESPERANDO</div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// SOLO MÓVIL
if (!/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
    // No forzar alert para pruebas en escritorio, pero puedes descomentar la línea siguiente
    // alert("Esta aplicación está pensada para móvil.");
}

// Bloquear orientación a landscape si es posible
if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock("landscape").catch(()=>{});
}

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.collisionsEnabled = true;

// PLAYER - CON ALTURA MODIFICADA
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", {height:1.8, radius:0.3}, scene);
playerMesh.isVisible = false;
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5,0.9,0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0,2,0); // MODIFICADO: de 0.9 a 2

// CÁMARA - CON ALTURA MODIFICADA
const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0,3,0), scene); // MODIFICADO: altura 335
camera.parent = playerMesh;
camera.checkCollisions = false;
camera.applyGravity = false;
// NO limpiar inputs para permitir touch look
camera.attachControl(canvas, true); // habilita rotación con touch
// Desactivar zoom por rueda si alguna vez se usa
if (camera.inputs && camera.inputs.attached && camera.inputs.attached.mousewheel) {
  camera.inputs.attached.mousewheel.detachControl(canvas);
}

// Luces
new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

// UI
const debug = document.getElementById("debug");
const speedBar = document.getElementById("speedBar");

// MOVIMIENTO: botones táctiles (adelante/atrás)
let moveForward=false, moveBackward=false;
let currentSpeed=0;
const maxSpeed=200;      // ajustar según quieras (m/s)
const maxReverseSpeed=120;
const accel=50;         // m/s^2
const airFriction=8;

const btnF=document.getElementById("btnForward");
const btnB=document.getElementById("btnBackward");
btnF.addEventListener("touchstart",(e)=>{ e.preventDefault(); moveForward=true; });
btnF.addEventListener("touchend",(e)=>{ e.preventDefault(); moveForward=false; });
btnB.addEventListener("touchstart",(e)=>{ e.preventDefault(); moveBackward=true; });
btnB.addEventListener("touchend",(e)=>{ e.preventDefault(); moveBackward=false; });

// JOYSTICK para rotación horizontal
const joystickContainer = document.getElementById("joystickContainer");
const joystickBase = document.getElementById("joystickBase");
const joystickHandle = document.getElementById("joystickHandle");

let isJoystickActive = false;
let joystickRotation = 0; // -1 a 1 (izquierda a derecha)
const rotationSpeed = 0.5; // REDUCIDO: Velocidad de rotación (radianes/segundo)
const minSpeedForSteering = 5; // Velocidad mínima para poder girar (m/s)

// Configurar eventos del joystick
joystickContainer.addEventListener('touchstart', handleJoystickStart);
joystickContainer.addEventListener('touchmove', handleJoystickMove);
joystickContainer.addEventListener('touchend', handleJoystickEnd);

function handleJoystickStart(e) {
  // Solo activar si estamos en movimiento
  if (Math.abs(currentSpeed) < minSpeedForSteering) return;
  
  e.preventDefault();
  isJoystickActive = true;
  updateJoystickPosition(e.touches[0]);
}

function handleJoystickMove(e) {
  // Solo activar si estamos en movimiento
  if (Math.abs(currentSpeed) < minSpeedForSteering) {
    resetJoystick();
    return;
  }
  
  if (!isJoystickActive) return;
  e.preventDefault();
  updateJoystickPosition(e.touches[0]);
}

function handleJoystickEnd(e) {
  e.preventDefault();
  isJoystickActive = false;
  resetJoystick();
}

function updateJoystickPosition(touch) {
  const rect = joystickBase.getBoundingClientRect();
  const baseCenterX = rect.left + rect.width / 2;
  const baseCenterY = rect.top + rect.height / 2;
  
  const touchX = touch.clientX;
  const touchY = touch.clientY;
  
  // Calcular distancia desde el centro
  const deltaX = touchX - baseCenterX;
  const deltaY = touchY - baseCenterY;
  
  // Limitar el movimiento del joystick al área del base
  const maxDistance = rect.width / 2 - joystickHandle.offsetWidth / 2;
  const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), maxDistance);
  
  // Calcular ángulo para determinar dirección
  const angle = Math.atan2(deltaY, deltaX);
  
  // Actualizar posición del handle
  const handleX = Math.cos(angle) * distance;
  joystickHandle.style.transform = `translate(calc(-50% + ${handleX}px), -50%)`;
  
  // Calcular rotación (-1 a 1) con curva de sensibilidad
  let rawRotation = handleX / maxDistance;
  
  // Aplicar curva de sensibilidad (menos sensible al inicio)
  if (Math.abs(rawRotation) < 0.3) {
    joystickRotation = rawRotation * 0.3; // Muy suave al inicio
  } else if (Math.abs(rawRotation) < 0.7) {
    joystickRotation = rawRotation * 0.6; // Sensibilidad media
  } else {
    joystickRotation = rawRotation; // Sensibilidad completa al final
  }
  
  // Limitar valores extremos
  joystickRotation = Math.max(-1, Math.min(1, joystickRotation));
}

function resetJoystick() {
  joystickHandle.style.transform = 'translate(-50%, -50%)';
  joystickRotation = 0;
}

function updateJoystickState() {
  // Activar/desactivar joystick según la velocidad
  if (Math.abs(currentSpeed) >= minSpeedForSteering) {
    joystickContainer.classList.remove('joystick-disabled');
  } else {
    joystickContainer.classList.add('joystick-disabled');
    if (isJoystickActive) {
      resetJoystick();
      isJoystickActive = false;
    }
  }
}

// SISTEMA DE CRONÓMETRO MEJORADO
const timerPanel = document.getElementById("timerPanel");
const currentTimer = document.getElementById("currentTimer");
const lapTimes = document.getElementById("lapTimes");
const timerStatus = document.getElementById("timerStatus");

let raceStartTime = 0;
let currentLapStartTime = 0;
let lastLapTime = 0;
let bestLapTime = 0;
let lapCount = 0;
let isRacing = false;
let hasCrossedFinishLine = false;

// Línea de meta CORREGIDA - usando las coordenadas originales del circuito
// Las coordenadas del circuito no cambian aunque modifiquemos la altura del jugador
const finishLine = {
  minX: 3750,
  maxX: 3800,
  z: 4025,
  width: 10 // Aumentamos el margen de detección
};

function formatTime(milliseconds) {
  const minutes = Math.floor(milliseconds / 60000);
  const seconds = Math.floor((milliseconds % 60000) / 1000);
  const ms = Math.floor(milliseconds % 1000);
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
}

function updateTimerDisplay() {
  if (isRacing) {
    const currentTime = Date.now() - currentLapStartTime;
    currentTimer.textContent = formatTime(currentTime);
  } else {
    currentTimer.textContent = "00:00.000";
  }
}

function checkFinishLine() {
  const pos = playerMesh.position;
  
  // DEBUG: Mostrar información de posición cerca de la línea de meta
  const nearFinishLine = Math.abs(pos.z - finishLine.z) < 50;
  if (nearFinishLine) {
    console.log(`Cerca de meta: X=${pos.x.toFixed(1)}, Z=${pos.z.toFixed(1)}`);
  }
  
  // Verificar si estamos cerca de la línea de meta en Z
  if (Math.abs(pos.z - finishLine.z) < finishLine.width) {
    // Verificar si estamos en el rango correcto de X
    if (pos.x >= finishLine.minX && pos.x <= finishLine.maxX) {
      if (!hasCrossedFinishLine) {
        hasCrossedFinishLine = true;
        
        if (!isRacing) {
          // Comenzar carrera
          isRacing = true;
          raceStartTime = Date.now();
          currentLapStartTime = raceStartTime;
          lapCount = 1;
          timerStatus.textContent = "VUELTA 1";
          timerStatus.style.color = "#0f0";
          console.log("¡CARRERA INICIADA!");
        } else {
          // Finalizar vuelta
          const lapTime = Date.now() - currentLapStartTime;
          lastLapTime = lapTime;
          
          // Actualizar mejor tiempo
          if (bestLapTime === 0 || lapTime < bestLapTime) {
            bestLapTime = lapTime;
          }
          
          // Agregar vuelta a la lista
          const lapElement = document.createElement("div");
          lapElement.className = "lap-time";
          if (lapTime === bestLapTime) {
            lapElement.classList.add("best-lap");
          }
          lapElement.textContent = `Vuelta ${lapCount}: ${formatTime(lapTime)}`;
          if (lapTime === bestLapTime) {
            lapElement.textContent += " ★";
          }
          
          lapTimes.insertBefore(lapElement, lapTimes.firstChild);
          
          // Actualizar contadores
          lapCount++;
          currentLapStartTime = Date.now();
          timerStatus.textContent = `VUELTA ${lapCount}`;
          console.log(`Vuelta ${lapCount-1} completada: ${formatTime(lapTime)}`);
        }
      }
    }
  } else {
    // Ya no estamos cerca de la línea de meta
    hasCrossedFinishLine = false;
  }
}

// Cargar circuito
BABYLON.SceneLoader.Append("", "spa.glb", scene, ()=>{
    scene.meshes.forEach(m=>{ if(m!==playerMesh) m.checkCollisions=true; });
    playerMesh.position.set(-3780,330,-3980);
    debug.textContent = "Circuito cargado - Busca la línea de meta en X:3750-3800, Z:4025";
    
    // DEBUG: Crear marcador visual de la línea de meta
    const finishLineMarker = BABYLON.MeshBuilder.CreateBox("finishLine", {width: 50, height: 10, depth: 2}, scene);
    finishLineMarker.position.set(3775, 340, 4025); // Posición de la línea de meta
    finishLineMarker.isVisible = true;
    
    const finishMaterial = new BABYLON.StandardMaterial("finishMat", scene);
    finishMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0); // Rojo brillante
    finishMaterial.alpha = 0.5; // Semi-transparente
    finishLineMarker.material = finishMaterial;
    
}, null, (s,msg)=>{ console.error(msg); debug.textContent = 'Error cargando spa.glb'; });

// Mantener en suelo
function keepGround(){
  const ray=new BABYLON.Ray(playerMesh.position.add(new BABYLON.Vector3(0,10,0)), new BABYLON.Vector3(0,-1,0), 50);
  const hit=scene.pickWithRay(ray, m=>m!==playerMesh);
  if(hit && hit.hit) playerMesh.position.y = hit.pickedPoint.y + 2; // Ajustado a la nueva altura
}

// LOOP principal (usamos solo yaw de la cámara - rotación y)
engine.runRenderLoop(()=>{
  const dt = engine.getDeltaTime()/1000;

  // ACELERACIÓN / FRENO
  if(moveForward && !moveBackward) currentSpeed = Math.min(currentSpeed + accel*dt, maxSpeed);
  else if(moveBackward && !moveForward) currentSpeed = Math.max(currentSpeed - accel*dt, -maxReverseSpeed);
  else {
    if(currentSpeed > 0) currentSpeed = Math.max(currentSpeed - airFriction*dt, 0);
    else if(currentSpeed < 0) currentSpeed = Math.min(currentSpeed + airFriction*dt, 0);
  }

  // Actualizar estado del joystick (activar/desactivar según velocidad)
  updateJoystickState();

  // ROTACIÓN con joystick (solo si estamos en movimiento)
  if (isJoystickActive && Math.abs(joystickRotation) > 0.1 && Math.abs(currentSpeed) >= minSpeedForSteering) {
    camera.rotation.y += joystickRotation * rotationSpeed * dt;
  }

  // Actualizar barra
  speedBar.style.width = (Math.min(Math.abs(currentSpeed) / maxSpeed, 1) * 100) + "%";
  speedBar.style.background = currentSpeed >= 0 ? "#0f0" : "#f00";

  // Desplazamiento: usar SOLO yaw (rotación Y) de la cámara; ignorar pitch
  if(Math.abs(currentSpeed) > 0.001){
    const yaw = camera.rotation.y;
    const forward = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    playerMesh.moveWithCollisions(forward.scale(currentSpeed * dt));
  }

  // Verificar línea de meta y actualizar cronómetro
  checkFinishLine();
  updateTimerDisplay();

  // Mantener en suelo y render
  keepGround();
  
  // Información de debug MEJORADA
  const joystickStatus = Math.abs(currentSpeed) >= minSpeedForSteering ? "ACTIVO" : "INACTIVO";
  const raceStatus = isRacing ? `CARRERA - Vuelta ${lapCount}` : "ESPERANDO EN META";
  const nearFinish = Math.abs(playerMesh.position.z - finishLine.z) < 50 ? "CERCA META" : "";
  
  debug.textContent = `Pos: X${playerMesh.position.x.toFixed(0)} Z${playerMesh.position.z.toFixed(0)} | ${raceStatus} | Vel: ${currentSpeed.toFixed(0)} km/h ${nearFinish}`;
  
  scene.render();
});

window.addEventListener('resize', ()=>engine.resize());
</script>
</body>
</html>
