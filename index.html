<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>SPA Model - Babylon.js</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            font-size: 18px;
            z-index: 1000;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="loading">Cargando modelo SPA...</div>
    <div id="controls" style="display: none;">
        <div>üñ±Ô∏è Rotar: Click + arrastrar</div>
        <div>üîç Zoom: Rueda del rat√≥n</div>
        <div>üì§ Pan: Click derecho + arrastrar</div>
    </div>

    <script>
        // Obtener el canvas
        const canvas = document.getElementById("renderCanvas");
        
        // Crear el motor de Babylon.js
        const engine = new BABYLON.Engine(canvas, true);
        
        // Crear la escena
        const createScene = function () {
            // Crear escena
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.1, 1.0);
            
            // Crear c√°mara
            const camera = new BABYLON.ArcRotateCamera(
                "camera", 
                -Math.PI / 2, 
                Math.PI / 2.5, 
                15, 
                BABYLON.Vector3.Zero(), 
                scene
            );
            camera.attachControls(canvas, true);
            camera.lowerRadiusLimit = 1;
            camera.upperRadiusLimit = 100;
            camera.wheelPrecision = 50;
            camera.panningSensibility = 1000;
            
            // Crear luces
            const light1 = new BABYLON.HemisphericLight(
                "light1", 
                new BABYLON.Vector3(0, 1, 0), 
                scene
            );
            light1.intensity = 0.7;
            
            const light2 = new BABYLON.DirectionalLight(
                "light2", 
                new BABYLON.Vector3(0, -1, -1), 
                scene
            );
            light2.intensity = 0.5;
            light2.position = new BABYLON.Vector3(0, 10, 0);
            
            // Luz adicional desde el frente
            const light3 = new BABYLON.PointLight(
                "light3",
                new BABYLON.Vector3(0, 5, 10),
                scene
            );
            light3.intensity = 0.3;

            // Crear ambiente
            const hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData(
                "https://assets.babylonjs.com/environments/environmentSpecular.env",
                scene
            );
            scene.environmentTexture = hdrTexture;
            scene.createDefaultSkybox(hdrTexture, true, 1000);
            
            return scene;
        };
        
        const scene = createScene();
        
        // Funci√≥n para cargar el modelo GLB
        const loadModel = async function () {
            const loadingElement = document.getElementById("loading");
            const controlsElement = document.getElementById("controls");
            
            try {
                loadingElement.innerHTML = "Cargando modelo SPA.glb...";
                
                // Cargar el modelo GLB
                const result = await BABYLON.SceneLoader.ImportMeshAsync(
                    "",
                    "./",
                    "spa.glb",
                    scene,
                    null,
                    ".glb"
                );
                
                console.log("Modelo cargado exitosamente:", result);
                
                // Ocultar loading y mostrar controles
                loadingElement.style.display = "none";
                controlsElement.style.display = "block";
                
                // Procesar el modelo cargado
                processLoadedModel(result.meshes, result);
                
            } catch (error) {
                console.error("Error cargando el modelo:", error);
                loadingElement.innerHTML = "Error cargando SPA.glb: " + error.message;
                
                // Crear modelo de fallback despu√©s de 3 segundos
                setTimeout(() => {
                    createFallbackModel();
                    loadingElement.style.display = "none";
                    controlsElement.style.display = "block";
                }, 3000);
            }
        };
        
        // Funci√≥n para procesar el modelo una vez cargado
        const processLoadedModel = function (meshes, result) {
            if (!meshes || meshes.length === 0) {
                console.warn("No se encontraron mallas en el modelo");
                return;
            }
            
            // Encontrar la malla ra√≠z
            let rootMesh = meshes[0];
            for (let mesh of meshes) {
                if (!mesh.parent) {
                    rootMesh = mesh;
                    break;
                }
            }
            
            console.log("Malla ra√≠z:", rootMesh.name);
            
            // Calcular el bounding box del modelo completo
            const boundingInfo = calculateTotalBoundingInfo(meshes);
            
            // Ajustar la c√°mara al modelo
            const camera = scene.activeCamera;
            if (camera && camera instanceof BABYLON.ArcRotateCamera) {
                // Establecer el objetivo en el centro del modelo
                camera.setTarget(boundingInfo.boundingBox.centerWorld);
                
                // Ajustar el radio de la c√°mara basado en el tama√±o del modelo
                const radius = boundingInfo.boundingSphere.radius * 2.5;
                camera.radius = Math.max(radius, 1);
                camera.lowerRadiusLimit = radius * 0.1;
                camera.upperRadiusLimit = radius * 10;
                
                console.log("C√°mara ajustada - Radio:", camera.radius, "Centro:", boundingInfo.boundingBox.centerWorld);
            }
            
            // Configurar materiales para mejor visualizaci√≥n
            setupMaterials(meshes);
            
            // Animaciones si existen
            if (result.animationGroups && result.animationGroups.length > 0) {
                console.log("Animaciones encontradas:", result.animationGroups.length);
                // Reproducir la primera animaci√≥n
                result.animationGroups[0].start(true);
            }
            
            // Habilitar sombras si es necesario
            enableShadows(meshes);
        };
        
        // Calcular el bounding box total de todas las mallas
        const calculateTotalBoundingInfo = function (meshes) {
            let min = null;
            let max = null;
            
            meshes.forEach(mesh => {
                if (mesh.getBoundingInfo) {
                    const boundingInfo = mesh.getBoundingInfo();
                    const boundingBox = boundingInfo.boundingBox;
                    
                    if (!min || !max) {
                        min = boundingBox.minimumWorld.clone();
                        max = boundingBox.maximumWorld.clone();
                    } else {
                        BABYLON.Vector3.Minimize(min, boundingBox.minimumWorld, min);
                        BABYLON.Vector3.Maximize(max, boundingBox.maximumWorld, max);
                    }
                }
            });
            
            if (!min || !max) {
                min = new BABYLON.Vector3(-1, -1, -1);
                max = new BABYLON.Vector3(1, 1, 1);
            }
            
            const center = BABYLON.Vector3.Center(min, max);
            const size = BABYLON.Vector3.Distance(min, max);
            
            const boundingBox = new BABYLON.BoundingBox(min, max);
            const boundingSphere = new BABYLON.BoundingSphere(center, size / 2);
            
            return {
                boundingBox: boundingBox,
                boundingSphere: boundingSphere
            };
        };
        
        // Configurar materiales para mejor visualizaci√≥n
        const setupMaterials = function (meshes) {
            meshes.forEach(mesh => {
                if (mesh.material) {
                    // Mejorar la apariencia de los materiales existentes
                    if (mesh.material instanceof BABYLON.PBRMaterial) {
                        mesh.material.environmentIntensity = 0.5;
                    } else if (mesh.material instanceof BABYLON.StandardMaterial) {
                        mesh.material.specularPower = 64;
                    }
                }
            });
        };
        
        // Habilitar sombras
        const enableShadows = function (meshes) {
            // Crear generador de sombras
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, scene.lights[1]);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;
            
            // Aplicar sombras a las mallas
            meshes.forEach(mesh => {
                if (mesh.receiveShadows !== undefined) {
                    mesh.receiveShadows = true;
                }
                if (mesh instanceof BABYLON.Mesh) {
                    shadowGenerator.addShadowCaster(mesh);
                }
            });
        };
        
        // Funci√≥n para crear un modelo de prueba como fallback
        const createFallbackModel = function () {
            console.log("Creando modelo de fallback...");
            
            // Crear un plano como base
            const ground = BABYLON.MeshBuilder.CreateGround(
                "ground", 
                { width: 10, height: 10 }, 
                scene
            );
            
            const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            ground.material = groundMaterial;
            
            // Crear algunas formas b√°sicas
            const box = BABYLON.MeshBuilder.CreateBox("box", { size: 2 }, scene);
            box.position.y = 1;
            
            const boxMaterial = new BABYLON.StandardMaterial("boxMat", scene);
            boxMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2);
            box.material = boxMaterial;
            
            const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 1.5 }, scene);
            sphere.position.x = 3;
            sphere.position.y = 0.75;
            
            const sphereMaterial = new BABYLON.StandardMaterial("sphereMat", scene);
            sphereMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.5, 0.8);
            sphere.material = sphereMaterial;
            
            console.log("Modelo de fallback creado");
        };
        
        // Iniciar carga del modelo cuando la escena est√© lista
        scene.executeWhenReady(function () {
            loadModel();
        });
        
        // Render loop
        engine.runRenderLoop(function () {
            scene.render();
        });
        
        // Manejar redimensionado de ventana
        window.addEventListener("resize", function () {
            engine.resize();
        });
        
        // Manejar errores del motor
        engine.onContextLostObservable.add(() => {
            console.warn("Contexto WebGL perdido");
        });
    </script>
</body>
</html>