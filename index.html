<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>SPA - Carreras Jerez - Cronómetro Corregido</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a0a0a">
<style>
html,body{margin:0;overflow:hidden;height:100%;background:#000}
#renderCanvas{width:100%;height:100%}
.button{position:absolute;bottom:30px;width:80px;height:80px;background:rgba(255,255,255,0.25);border-radius:50%;pointer-events:auto;}
#btnForward{right:40px}
#btnBackward{right:140px}
#speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
#speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
#debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
#joystickContainer { position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px; pointer-events: auto; z-index: 10; }
#joystickBase { position: absolute; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); }
#joystickHandle { position: absolute; width: 60px; height: 60px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s; }
#joystickAxis { position: absolute; width: 100%; height: 4px; background: rgba(255, 255, 255, 0.2); top: 50%; left: 0; transform: translateY(-50%); }
.joystick-disabled { opacity: 0.5; pointer-events: none; }
#timerPanel { position: absolute; top: 10px; right: 10px; width: 150px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 5px; color: #fff; font-family: monospace; z-index: 10; font-size: 12px;}
#currentTimer { font-size: 18px; text-align: center; margin-bottom: 5px; color: #0f0; }
#lapTimes { font-size: 10px; max-height: 100px; overflow-y: auto; }
.lap-time { padding: 1px 0; border-bottom: 1px solid #444; }
.lap-time:last-child { border-bottom: none; }
.best-lap { color: #ff0; font-weight: bold; }
#timerStatus { text-align: center; font-size: 12px; margin-top: 2px; color: #0ff; }
#bestLapDisplay { text-align: center; font-size: 12px; margin-top: 2px; color: #ff0; }

/* Botón pantalla completa */
#fullscreenBtn{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    padding:15px 25px;
    font-size:20px;
    background:rgba(0,0,0,0.7);
    color:#0f0;
    border:2px solid #0f0;
    border-radius:10px;
    z-index:100;
    cursor: pointer;
}

/* Botón configuración */
#settingsBtn{
    position:absolute;
    top:10px;
    right:170px;
    width:50px;
    height:50px;
    background:rgba(255,255,255,0.25);
    border-radius:50%;
    font-size:28px;
    text-align:center;
    line-height:50px;
    cursor:pointer;
    z-index:100;
}

/* Panel de configuración */
#settingsPanel{
    position:absolute;
    top:70px;
    right:10px;
    width:240px;
    background:rgba(0,0,0,0.85);
    border:2px solid #fff;
    border-radius:10px;
    padding:10px;
    color:#fff;
    font-family:monospace;
    display:none;
    z-index:101;
}
#settingsPanel label{display:block;margin:5px 0 2px;}
#settingsPanel input[type=range]{width:100%;}
#settingsPanel select, #settingsPanel input[type=number]{width:100%;margin-bottom:5px;}
#settingsPanel button{width:100%;padding:5px;margin-top:5px;}

/* Indicador de posición de meta */
#finishLineIndicator {
    position: absolute;
    top: 50%;
    left: 10px;
    transform: translateY(-50%);
    width: 120px;
    background: rgba(0,0,0,0.7);
    border: 2px solid #0f0;
    border-radius: 5px;
    padding: 5px;
    color: #0f0;
    font-family: monospace;
    font-size: 12px;
    text-align: center;
    z-index: 10;
}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando circuito...</div>
<div class="button" id="btnForward" title="Acelerar"></div>
<div class="button" id="btnBackward" title="Freno / marcha atrás"></div>

<div id="joystickContainer" class="joystick-disabled">
  <div id="joystickBase">
    <div id="joystickAxis"></div>
    <div id="joystickHandle"></div>
  </div>
</div>

<div id="timerPanel">
  <div id="currentTimer">00:00.000</div>
  <div id="lapTimes"></div>
  <div id="timerStatus">ESPERANDO EN META</div>
  <div id="bestLapDisplay">MEJOR VUELTA: --:--.---</div>
</div>

<div id="finishLineIndicator">
  <div>LÍNEA DE META</div>
  <div id="finishLineStatus">NO ACTIVA</div>
</div>

<!-- Botones -->
<button id="fullscreenBtn">INICIAR CARRERA</button>
<div id="settingsBtn">⚙️</div>
<div id="settingsPanel">
    <label>Velocidad Máx: <span id="maxSpeedLabel">330</span></label>
    <input type="range" id="maxSpeedRange" min="50" max="500" value="330">
    
    <label>Aceleración: <span id="accelLabel">50</span></label>
    <input type="range" id="accelRange" min="10" max="200" value="50">

    <label>Freno: <span id="brakeLabel">150</span></label>
    <input type="range" id="brakeRange" min="20" max="300" value="150">

    <label>Clima</label>
    <select id="weatherSelect">
        <option value="sunny">Soleado</option>
        <option value="gray">Cielo Gris</option>
        <option value="sunset">Atardecer Azul</option>
    </select>

    <label>Niebla: <span id="fogLabel">0.00</span></label>
    <input type="range" id="fogRange" min="0" max="0.04" step="0.01" value="0">

    <label>Música</label>
    <button id="musicBtn">On</button>

    <label>Número de Vueltas</label>
    <input type="number" id="lapsNumber" min="1" max="99" value="3">
    
    <button id="resetRaceBtn">Reiniciar Carrera</button>
</div>

<audio id="motorAudio" loop>
  <source src="https://assets.mixkit.co/active_storage/sfx/231/231-preview.mp3" type="audio/mp3">
</audio>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// =========================
// Fullscreen
// =========================
const fullscreenBtn = document.getElementById("fullscreenBtn");
fullscreenBtn.addEventListener('click', () => {
    document.documentElement.requestFullscreen?.().catch(() => {});
    if (screen.orientation && screen.orientation.lock) screen.orientation.lock("landscape").catch(() => {});
    fullscreenBtn.style.display = 'none';
});

// =========================
// Configuración
// =========================
const settingsBtn = document.getElementById("settingsBtn");
const settingsPanel = document.getElementById("settingsPanel");
settingsBtn.addEventListener('click', () => { 
    settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none'; 
});

// Velocidad/Aceleración/Freno
const maxSpeedRange = document.getElementById("maxSpeedRange"), 
      accelRange = document.getElementById("accelRange"), 
      brakeRange = document.getElementById("brakeRange");
const maxSpeedLabel = document.getElementById("maxSpeedLabel"), 
      accelLabel = document.getElementById("accelLabel"), 
      brakeLabel = document.getElementById("brakeLabel");

let maxSpeed = 330, accel = 50, brakeFriction = 150;
maxSpeedRange.addEventListener('input', () => { 
    maxSpeed = parseInt(maxSpeedRange.value); 
    maxSpeedLabel.textContent = maxSpeed; 
});
accelRange.addEventListener('input', () => { 
    accel = parseInt(accelRange.value); 
    accelLabel.textContent = accel; 
});
brakeRange.addEventListener('input', () => { 
    brakeFriction = parseInt(brakeRange.value); 
    brakeLabel.textContent = brakeFriction; 
});

// Clima y niebla
const weatherSelect = document.getElementById("weatherSelect");
const fogRange = document.getElementById("fogRange"), fogLabel = document.getElementById("fogLabel");
let fogDensity = 0;
fogRange.addEventListener('input', () => {
    fogDensity = parseFloat(fogRange.value);
    fogLabel.textContent = fogDensity.toFixed(2);
});

// Música
const musicBtn = document.getElementById("musicBtn"), motorAudio = document.getElementById("motorAudio");
let musicOn = true;
musicBtn.addEventListener('click', () => {
    musicOn = !musicOn;
    if (musicOn) motorAudio.play().catch(e => console.log("Audio no disponible:", e));
    else motorAudio.pause();
    musicBtn.textContent = musicOn ? "On" : "Off";
});

// Número de vueltas
const lapsNumberInput = document.getElementById("lapsNumber");
let totalLaps = parseInt(lapsNumberInput.value);
lapsNumberInput.addEventListener('input', () => { 
    totalLaps = parseInt(lapsNumberInput.value); 
    if (isNaN(totalLaps) || totalLaps < 1) totalLaps = 1;
});

// Reiniciar carrera
const resetRaceBtn = document.getElementById("resetRaceBtn");
resetRaceBtn.addEventListener('click', resetRace);

// =========================
// BabylonJS Juego
// =========================
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.collisionsEnabled = true;

// CIELO
scene.clearColor = new BABYLON.Color4(0.4, 0.7, 1, 1);
const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
hemiLight.diffuse = new BABYLON.Color3(0.8, 0.9, 1);
hemiLight.groundColor = new BABYLON.Color3(0.2, 0.4, 0.8);
hemiLight.intensity = 1.2;
const dirLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5, -1, 0.5), scene);
dirLight.diffuse = new BABYLON.Color3(1, 0.95, 0.8);
dirLight.intensity = 0.8;
dirLight.specular = new BABYLON.Color3(0.1, 0.1, 0.1);
scene.ambientColor = new BABYLON.Color3(0.4, 0.5, 0.7);

// Niebla
scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
scene.fogColor = new BABYLON.Color3(0.5, 0.5, 0.5);

// PLAYER
const playerMesh = BABYLON.MeshBuilder.CreateCapsule("player", {height: 1.8, radius: 0.3}, scene);
playerMesh.isVisible = false;
playerMesh.checkCollisions = true;
playerMesh.ellipsoid = new BABYLON.Vector3(0.5, 3, 0.5);
playerMesh.ellipsoidOffset = new BABYLON.Vector3(0, 2, 0);

// CAMERA
const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 3, 0), scene);
camera.parent = playerMesh;
camera.attachControl(canvas, true);

// UI
const debug = document.getElementById("debug");
const speedBar = document.getElementById("speedBar");
const finishLineStatus = document.getElementById("finishLineStatus");

// MOVIMIENTO
let moveForward = false, moveBackward = false, currentSpeed = 0;
let maxReverse = 50, airFriction = 8;
document.getElementById("btnForward").addEventListener("touchstart", () => moveForward = true);
document.getElementById("btnForward").addEventListener("touchend", () => moveForward = false);
document.getElementById("btnBackward").addEventListener("touchstart", () => moveBackward = true);
document.getElementById("btnBackward").addEventListener("touchend", () => moveBackward = false);

// JOYSTICK
const joystickContainer = document.getElementById("joystickContainer");
const joystickHandle = document.getElementById("joystickHandle");
let isJoystickActive = false, joystickRotation = 0;
const rotationSpeed = 0.5, minSpeedForSteering = 5;
joystickContainer.addEventListener('touchstart', e => { 
    if (Math.abs(currentSpeed) < minSpeedForSteering) return; 
    e.preventDefault(); 
    isJoystickActive = true; 
    updateJoystick(e.touches[0]); 
});
joystickContainer.addEventListener('touchmove', e => { 
    if (Math.abs(currentSpeed) < minSpeedForSteering) { 
        resetJoystick(); 
        return; 
    } 
    if (!isJoystickActive) return; 
    e.preventDefault(); 
    updateJoystick(e.touches[0]); 
});
joystickContainer.addEventListener('touchend', e => { 
    e.preventDefault(); 
    isJoystickActive = false; 
    resetJoystick(); 
});
function updateJoystick(touch) { 
    const rect = joystickContainer.getBoundingClientRect(); 
    const dx = touch.clientX - (rect.left + rect.width / 2); 
    const maxDist = rect.width / 2 - joystickHandle.offsetWidth / 2; 
    const dist = Math.min(Math.abs(dx), maxDist); 
    joystickHandle.style.transform = `translate(calc(-50% + ${Math.sign(dx) * dist}px), -50%)`; 
    joystickRotation = Math.max(-1, Math.min(1, dx / maxDist)); 
}
function resetJoystick() { 
    joystickHandle.style.transform = 'translate(-50%, -50%)'; 
    joystickRotation = 0; 
}
function updateJoystickState() { 
    if (Math.abs(currentSpeed) >= minSpeedForSteering) {
        joystickContainer.classList.remove('joystick-disabled'); 
    } else { 
        joystickContainer.classList.add('joystick-disabled'); 
        if (isJoystickActive) { 
            resetJoystick(); 
            isJoystickActive = false; 
        }
    }
}

// =========================
// CRONÓMETRO MEJORADO
// =========================
const currentTimer = document.getElementById("currentTimer");
const lapTimes = document.getElementById("lapTimes");
const timerStatus = document.getElementById("timerStatus");
const bestLapDisplay = document.getElementById("bestLapDisplay");

let raceStartTime = 0, 
    currentLapStartTime = 0, 
    bestLapTime = 0, 
    lapCount = 0, 
    isRacing = false, 
    hasCrossedFinishLine = false, 
    prevPosZ = 0;

// LÍNEA DE META MEJORADA
const finishLine = {
    minX: 270,           // Margen más amplio en X
    maxX: 290,           // Margen más amplio en X  
    z: -325,             // Posición Z central de la línea de meta
    width: 15,           // Ancho de detección
    directionThreshold: 2 // Velocidad mínima en Z para considerar cruce válido
};

function formatTime(ms) {
    const m = Math.floor(ms / 60000),
          s = Math.floor((ms % 60000) / 1000),
          msr = Math.floor(ms % 1000); 
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${msr.toString().padStart(3, '0')}`;
}

function updateTimerDisplay() { 
    currentTimer.textContent = isRacing ? formatTime(Date.now() - currentLapStartTime) : "00:00.000"; 
    bestLapDisplay.textContent = bestLapTime > 0 ? `MEJOR VUELTA: ${formatTime(bestLapTime)}` : "MEJOR VUELTA: --:--.---"; 
}

function registerCross() { 
    if (!isRacing) {
        // Iniciar carrera
        isRacing = true; 
        raceStartTime = Date.now(); 
        currentLapStartTime = raceStartTime; 
        lapCount = 1; 
        timerStatus.textContent = "VUELTA 1"; 
        timerStatus.style.color = "#0f0"; 
        console.log("Carrera iniciada - Vuelta 1");
        return; 
    } 
    
    // Registrar vuelta completada
    const lapTime = Date.now() - currentLapStartTime; 
    
    // Solo registrar como mejor vuelta si es mayor a 3 segundos (evita registros accidentales)
    if (lapTime > 3000) {
        if (bestLapTime === 0 || lapTime < bestLapTime) {
            bestLapTime = lapTime;
        }
        
        const lapEl = document.createElement("div"); 
        lapEl.className = "lap-time"; 
        lapEl.textContent = `Vuelta ${lapCount}: ${formatTime(lapTime)}` + (lapTime === bestLapTime ? " ★" : ""); 
        if (lapTime === bestLapTime) lapEl.classList.add("best-lap"); 
        lapTimes.insertBefore(lapEl, lapTimes.firstChild); 
        
        console.log(`Vuelta ${lapCount} completada: ${formatTime(lapTime)}`);
    }
    
    lapCount++; 
    currentLapStartTime = Date.now(); 
    
    if (lapCount > totalLaps) { 
        timerStatus.textContent = "CARRERA COMPLETADA"; 
        timerStatus.style.color = "#ff0";
        isRacing = false; 
        console.log("Carrera completada");
    } else { 
        timerStatus.textContent = `VUELTA ${lapCount}`; 
    }
}

function checkFinishLine() { 
    const pos = playerMesh.position; 
    const deltaZ = pos.z - prevPosZ; // Velocidad en eje Z
    
    // Verificar si estamos en el rango X de la línea de meta
    const insideX = (pos.x >= finishLine.minX && pos.x <= finishLine.maxX);
    
    // Verificar si estamos cerca de la línea de meta en Z
    const nearFinishZ = Math.abs(pos.z - finishLine.z) <= finishLine.width;
    
    // Actualizar indicador de meta
    if (insideX && nearFinishZ) {
        finishLineStatus.textContent = "EN META";
        finishLineStatus.style.color = "#0f0";
    } else {
        finishLineStatus.textContent = "NO ACTIVA";
        finishLineStatus.style.color = "#f00";
    }
    
    if (insideX && nearFinishZ) { 
        // Detectar cruce basado en dirección y velocidad
        if (!hasCrossedFinishLine) {
            // Cruzando en dirección positiva (de valores más negativos a menos negativos)
            if (deltaZ > finishLine.directionThreshold && prevPosZ < finishLine.z && pos.z >= finishLine.z) {
                hasCrossedFinishLine = true;
                registerCross();
                console.log("Cruce detectado - dirección positiva");
            }
            // Cruzando en dirección negativa (de valores menos negativos a más negativos)  
            else if (deltaZ < -finishLine.directionThreshold && prevPosZ > finishLine.z && pos.z <= finishLine.z) {
                hasCrossedFinishLine = true;
                registerCross();
                console.log("Cruce detectado - dirección negativa");
            }
        }
    } 
    
    // Resetear el flag cuando nos alejamos suficientemente de la línea
    if (Math.abs(pos.z - finishLine.z) > finishLine.width * 2) {
        hasCrossedFinishLine = false;
    }
    
    prevPosZ = pos.z; 
}

function resetRace() {
    isRacing = false;
    hasCrossedFinishLine = false;
    lapCount = 0;
    bestLapTime = 0;
    currentLapStartTime = 0;
    raceStartTime = 0;
    
    // Resetear UI
    currentTimer.textContent = "00:00.000";
    lapTimes.innerHTML = "";
    timerStatus.textContent = "ESPERANDO EN META";
    timerStatus.style.color = "#0ff";
    bestLapDisplay.textContent = "MEJOR VUELTA: --:--.---";
    
    // Reposicionar jugador
    playerMesh.position.set(280, 74, -340);
    prevPosZ = playerMesh.position.z;
    
    console.log("Carrera reiniciada");
}

// CARGAR CIRCUITO JEREZ (o crear uno temporal si no existe)
function loadCircuit() {
    // Intentar cargar el modelo Jerez
    BABYLON.SceneLoader.Append("", "jerez.glb", scene, () => {
        scene.meshes.forEach(m => { 
            if (m !== playerMesh) m.checkCollisions = true; 
        });
        
        // Posición inicial cerca de la línea de meta
        playerMesh.position.set(280, 74, -340);
        prevPosZ = playerMesh.position.z;
        
        debug.textContent = "Circuito Jerez cargado - Línea de meta activa";
        console.log("Circuito Jerez cargado correctamente");
        
    }, null, (s, msg) => { 
        // Si falla la carga, crear un circuito básico
        console.error("Error cargando jerez.glb:", msg);
        createBasicCircuit();
        debug.textContent = "Circuito básico generado - Usando línea de meta virtual";
    });
}

function createBasicCircuit() {
    // Crear un suelo básico
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 1000, height: 1000}, scene);
    ground.checkCollisions = true;
    
    // Crear algunos objetos como referencia
    const finishLineObj = BABYLON.MeshBuilder.CreateBox("finishLine", {width: 20, height: 5, depth: 1}, scene);
    finishLineObj.position.set(280, 2.5, -325);
    finishLineObj.material = new BABYLON.StandardMaterial("finishMat", scene);
    finishLineObj.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
    
    // Crear bordes del circuito
    const border1 = BABYLON.MeshBuilder.CreateBox("border1", {width: 10, height: 3, depth: 800}, scene);
    border1.position.set(250, 1.5, 0);
    border1.checkCollisions = true;
    
    const border2 = BABYLON.MeshBuilder.CreateBox("border2", {width: 10, height: 3, depth: 800}, scene);
    border2.position.set(310, 1.5, 0);
    border2.checkCollisions = true;
    
    // Posición inicial
    playerMesh.position.set(280, 74, -340);
    prevPosZ = playerMesh.position.z;
}

function keepGround() { 
    const ray = new BABYLON.Ray(playerMesh.position.add(n
