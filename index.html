<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>SPA - Lamborghini Racing</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a0a0a">
<style>
html,body{margin:0;overflow:hidden;height:100%;background:#000}
#renderCanvas{width:100%;height:100%}
.button{position:absolute;bottom:30px;width:80px;height:80px;background:rgba(255,255,255,0.25);border-radius:50%;pointer-events:auto;}
#btnForward{right:40px}
#btnBackward{right:140px}
#speedBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
#speedBar{height:100%;width:0%;background:#0f0;transition:width .15s}
#debug{position:absolute;top:40px;left:10px;color:#fff;font-size:14px;font-family:monospace;z-index:9}
#joystickContainer { position: absolute; bottom: 30px; left: 30px; width: 120px; height: 120px; pointer-events: auto; z-index: 10; }
#joystickBase { position: absolute; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.3); }
#joystickHandle { position: absolute; width: 60px; height: 60px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: transform 0.05s; }
#joystickAxis { position: absolute; width: 100%; height: 4px; background: rgba(255, 255, 255, 0.2); top: 50%; left: 0; transform: translateY(-50%); }
.joystick-disabled { opacity: 0.5; pointer-events: none; }
#timerPanel { position: absolute; top: 10px; right: 10px; width: 150px; background: rgba(0,0,0,0.7); border: 2px solid #fff; border-radius: 10px; padding: 5px; color: #fff; font-family: monospace; z-index: 10; font-size: 12px;}
#currentTimer { font-size: 18px; text-align: center; margin-bottom: 5px; color: #0f0; }
#lapTimes { font-size: 10px; max-height: 100px; overflow-y: auto; }
.lap-time { padding: 1px 0; border-bottom: 1px solid #444; }
.lap-time:last-child { border-bottom: none; }
.best-lap { color: #ff0; font-weight: bold; }
#timerStatus { text-align: center; font-size: 12px; margin-top: 2px; color: #0ff; }
#bestLapDisplay { text-align: center; font-size: 12px; margin-top: 2px; color: #ff0; }

/* Botón pantalla completa */
#fullscreenBtn{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    padding:15px 25px;
    font-size:20px;
    background:rgba(0,0,0,0.7);
    color:#0f0;
    border:2px solid #0f0;
    border-radius:10px;
    z-index:100;
}

/* Botón configuración */
#settingsBtn{
    position:absolute;
    top:10px;
    right:10px;
    width:50px;
    height:50px;
    background:rgba(255,255,255,0.25);
    border-radius:50%;
    font-size:28px;
    text-align:center;
    line-height:50px;
    cursor:pointer;
    z-index:100;
}

/* Panel de configuración */
#settingsPanel{
    position:absolute;
    top:70px;
    right:10px;
    width:240px;
    background:rgba(0,0,0,0.85);
    border:2px solid #fff;
    border-radius:10px;
    padding:10px;
    color:#fff;
    font-family:monospace;
    display:none;
    z-index:101;
}
#settingsPanel label{display:block;margin:5px 0 2px;}
#settingsPanel input[type=range]{width:100%;}
#settingsPanel select, #settingsPanel input[type=number]{width:100%;margin-bottom:5px;}
#settingsPanel button{width:100%;padding:5px;margin-top:5px;}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="speedBarContainer"><div id="speedBar"></div></div>
<div id="debug">Cargando...</div>
<div class="button" id="btnForward" title="Acelerar"></div>
<div class="button" id="btnBackward" title="Freno / marcha atrás"></div>

<div id="joystickContainer" class="joystick-disabled">
  <div id="joystickBase">
    <div id="joystickAxis"></div>
    <div id="joystickHandle"></div>
  </div>
</div>

<div id="timerPanel">
  <div id="currentTimer">00:00.000</div>
  <div id="lapTimes"></div>
  <div id="timerStatus">ESPERANDO EN META</div>
  <div id="bestLapDisplay">MEJOR VUELTA: --:--.---</div>
</div>

<!-- Botones -->
<button id="fullscreenBtn">Pantalla Completa</button>
<div id="settingsBtn">⚙️</div>
<div id="settingsPanel">
    <label>Velocidad Máx: <span id="maxSpeedLabel">100</span></label>
    <input type="range" id="maxSpeedRange" min="50" max="500" value="100">
    
    <label>Aceleración: <span id="accelLabel">30</span></label>
    <input type="range" id="accelRange" min="10" max="200" value="30">

    <label>Freno: <span id="brakeLabel">60</span></label>
    <input type="range" id="brakeRange" min="20" max="300" value="60">

    <label>Clima</label>
    <select id="weatherSelect">
        <option value="sunny">Soleado</option>
        <option value="gray">Cielo Gris</option>
        <option value="sunset">Atardecer Azul</option>
    </select>

    <label>Niebla: <span id="fogLabel">0.000</span></label>
    <input type="range" id="fogRange" min="0" max="0.009" step="0.001" value="0">

    <label>Música</label>
    <button id="musicBtn">On</button>

    <label>Número de Vueltas</label>
    <input type="number" id="lapsNumber" min="1" max="99" value="3">
</div>

<audio id="motorAudio" src="motor.mp3" loop></audio>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// =========================
// Fullscreen
// =========================
const fullscreenBtn=document.getElementById("fullscreenBtn");
fullscreenBtn.addEventListener('click', ()=>{
    document.documentElement.requestFullscreen?.().catch(()=>{});
    if(screen.orientation && screen.orientation.lock) screen.orientation.lock("landscape").catch(()=>{});
    fullscreenBtn.style.display='none';
});

// =========================
// Configuración
// =========================
const settingsBtn=document.getElementById("settingsBtn");
const settingsPanel=document.getElementById("settingsPanel");
settingsBtn.addEventListener('click', ()=>{ settingsPanel.style.display = settingsPanel.style.display==='none'?'block':'none'; });

// Velocidad/Aceleración/Freno
const maxSpeedRange=document.getElementById("maxSpeedRange"), accelRange=document.getElementById("accelRange"), brakeRange=document.getElementById("brakeRange");
const maxSpeedLabel=document.getElementById("maxSpeedLabel"), accelLabel=document.getElementById("accelLabel"), brakeLabel=document.getElementById("brakeLabel");

let maxSpeed=100, accel=30, brakeFriction=60;
maxSpeedRange.addEventListener('input', ()=>{ maxSpeed=parseInt(maxSpeedRange.value); maxSpeedLabel.textContent=maxSpeed; });
accelRange.addEventListener('input', ()=>{ accel=parseInt(accelRange.value); accelLabel.textContent=accel; });
brakeRange.addEventListener('input', ()=>{ brakeFriction=parseInt(brakeRange.value); brakeLabel.textContent=brakeFriction; });

// Clima y niebla
const weatherSelect=document.getElementById("weatherSelect");
const fogRange=document.getElementById("fogRange"), fogLabel=document.getElementById("fogLabel");
let fogDensity=0;
fogRange.addEventListener('input', ()=>{
    fogDensity = parseFloat(fogRange.value);
    fogLabel.textContent=fogDensity.toFixed(3);
});

// Música
const musicBtn=document.getElementById("musicBtn"), motorAudio=document.getElementById("motorAudio");
let musicOn=true;
musicBtn.addEventListener('click', ()=>{
    musicOn=!musicOn;
    if(musicOn) motorAudio.play();
    else motorAudio.pause();
    musicBtn.textContent=musicOn?"On":"Off";
});

// Número de vueltas
const lapsNumberInput=document.getElementById("lapsNumber");
let totalLaps=parseInt(lapsNumberInput.value);
lapsNumberInput.addEventListener('input', ()=>{ totalLaps=parseInt(lapsNumberInput.value); });

// =========================
// BabylonJS Juego
// =========================
const canvas=document.getElementById("renderCanvas");
const engine=new BABYLON.Engine(canvas,true);
const scene=new BABYLON.Scene(engine);
scene.collisionsEnabled=true;

// CIELO
scene.clearColor=new BABYLON.Color4(0.4,0.7,1,1);
const hemiLight=new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
hemiLight.diffuse=new BABYLON.Color3(0.8,0.9,1);
hemiLight.groundColor=new BABYLON.Color3(0.2,0.4,0.8);
hemiLight.intensity=1.2;
const dirLight=new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.5,-1,0.5), scene);
dirLight.diffuse=new BABYLON.Color3(1,0.95,0.8);
dirLight.intensity=0.8;
dirLight.specular=new BABYLON.Color3(0.1,0.1,0.1);
scene.ambientColor=new BABYLON.Color3(0.4,0.5,0.7);

// Niebla
scene.fogMode=BABYLON.Scene.FOGMODE_EXP2;
scene.fogColor=new BABYLON.Color3(0.5,0.5,0.5);

// VARIABLES
let car = null;
let camera = null;

// UI
const debug=document.getElementById("debug");
const speedBar=document.getElementById("speedBar");

// MOVIMIENTO
let moveForward=false, moveBackward=false, currentSpeed=0;
let maxReverse=40, airFriction=5;
document.getElementById("btnForward").addEventListener("touchstart",()=>moveForward=true);
document.getElementById("btnForward").addEventListener("touchend",()=>moveForward=false);
document.getElementById("btnBackward").addEventListener("touchstart",()=>moveBackward=true);
document.getElementById("btnBackward").addEventListener("touchend",()=>moveBackward=false);

// JOYSTICK
const joystickContainer=document.getElementById("joystickContainer");
const joystickHandle=document.getElementById("joystickHandle");
let isJoystickActive=false, joystickRotation=0;
const rotationSpeed=2.5, minSpeedForSteering=1;
joystickContainer.addEventListener('touchstart', e=>{ 
    if(Math.abs(currentSpeed)<minSpeedForSteering) return; 
    e.preventDefault(); 
    isJoystickActive=true; 
    updateJoystick(e.touches[0]); 
});
joystickContainer.addEventListener('touchmove', e=>{ 
    if(Math.abs(currentSpeed)<minSpeedForSteering){ resetJoystick(); return; } 
    if(!isJoystickActive) return; 
    e.preventDefault(); 
    updateJoystick(e.touches[0]); 
});
joystickContainer.addEventListener('touchend', e=>{ 
    e.preventDefault(); 
    isJoystickActive=false; 
    resetJoystick(); 
});
function updateJoystick(touch){ 
    const rect=joystickContainer.getBoundingClientRect(); 
    const dx=touch.clientX-(rect.left+rect.width/2); 
    const maxDist=rect.width/2-joystickHandle.offsetWidth/2; 
    const dist=Math.min(Math.abs(dx),maxDist); 
    joystickHandle.style.transform=`translate(calc(-50% + ${Math.sign(dx)*dist}px), -50%)`; 
    joystickRotation=Math.max(-1,Math.min(1,dx/maxDist)); 
}
function resetJoystick(){ 
    joystickHandle.style.transform='translate(-50%,-50%)'; 
    joystickRotation=0; 
}
function updateJoystickState(){ 
    if(Math.abs(currentSpeed)>=minSpeedForSteering) {
        joystickContainer.classList.remove('joystick-disabled'); 
    } else { 
        joystickContainer.classList.add('joystick-disabled'); 
        if(isJoystickActive){ 
            resetJoystick(); 
            isJoystickActive=false; 
        }
    }
}

// CRONÓMETRO
const currentTimer=document.getElementById("currentTimer");
const lapTimes=document.getElementById("lapTimes");
const timerStatus=document.getElementById("timerStatus");
const bestLapDisplay=document.getElementById("bestLapDisplay");
let raceStartTime=0,currentLapStartTime=0,bestLapTime=0,lapCount=0,isRacing=false,hasCrossedFinishLine=false,prevPosZ=0;
const finishLine={minX:-3800,maxX:-3700,z:-4025,width:30,resetThresholdExtra:10};
finishLine.centerX=(finishLine.minX+finishLine.maxX)/2;
finishLine.resetThreshold=finishLine.width+finishLine.resetThresholdExtra;
function formatTime(ms){
    const m=Math.floor(ms/60000),
          s=Math.floor((ms%60000)/1000),
          msr=Math.floor(ms%1000); 
    return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${msr.toString().padStart(3,'0')}`;
}
function updateTimerDisplay(){ 
    currentTimer.textContent=isRacing?formatTime(Date.now()-currentLapStartTime):"00:00.000"; 
    bestLapDisplay.textContent=bestLapTime>0?`MEJOR VUELTA: ${formatTime(bestLapTime)}`:"MEJOR VUELTA: --:--.---"; 
}
function registerCross(){ 
    if(!isRacing){
        isRacing=true; 
        raceStartTime=Date.now(); 
        currentLapStartTime=raceStartTime; 
        lapCount=1; 
        timerStatus.textContent="VUELTA 1"; 
        timerStatus.style.color="#0f0"; 
        return; 
    } 
    const lapTime=Date.now()-currentLapStartTime; 
    if(bestLapTime===0||lapTime<bestLapTime) bestLapTime=lapTime; 
    const lapEl=document.createElement("div"); 
    lapEl.className="lap-time"; 
    lapEl.textContent=`Vuelta ${lapCount}: ${formatTime(lapTime)}`+(lapTime===bestLapTime?" ★":""); 
    if(lapTime===bestLapTime) lapEl.classList.add("best-lap"); 
    lapTimes.insertBefore(lapEl,lapTimes.firstChild); 
    lapCount++; 
    currentLapStartTime=Date.now(); 
    if(lapCount>totalLaps){ 
        timerStatus.textContent="CARRERA COMPLETADA"; 
        isRacing=false; 
    } else { 
        timerStatus.textContent=`VUELTA ${lapCount}`; 
    }
}
function checkFinishLine(){ 
    if (!car) return;
    const pos=car.position; 
    const insideX=(pos.x>=finishLine.minX && pos.x<=finishLine.maxX); 
    if(insideX){ 
        if(!hasCrossedFinishLine && prevPosZ<finishLine.z && pos.z>=finishLine.z && Math.abs(pos.z-finishLine.z)<=finishLine.width){ 
            hasCrossedFinishLine=true; 
            registerCross(); 
        } else if(!hasCrossedFinishLine && prevPosZ>finishLine.z && pos.z<=finishLine.z && Math.abs(pos.z-finishLine.z)<=finishLine.width){ 
            hasCrossedFinishLine=true; 
            registerCross(); 
        } 
    } 
    if(Math.abs(pos.z-finishLine.z)>finishLine.resetThreshold) hasCrossedFinishLine=false; 
    prevPosZ=pos.z; 
}

// INICIAR JUEGO
function initGame() {
    // Crear cámara primero
    camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 2, -8), scene);
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.attachControl(canvas, true);
    
    // Cargar circuito
    BABYLON.SceneLoader.Append("", "spa.glb", scene, function(){
        // Cargar Lambo después del circuito
        BABYLON.SceneLoader.ImportMesh("", "", "lambo.glb", scene, function (meshes) {
            car = meshes[0];
            car.name = "lambo";
            car.checkCollisions = true;
            
            // Posición INICIAL EN LA META
            car.position = new BABYLON.Vector3(-3750, 335, -4025);
            car.scaling = new BABYLON.Vector3(2, 2, 2);
            
            // Configurar collider
            const collider = BABYLON.MeshBuilder.CreateBox("collider", {
                width: 1.8,
                height: 0.6,
                depth: 4
            }, scene);
            collider.isVisible = false;
            collider.checkCollisions = true;
            collider.parent = car;
            collider.position.y = 0.3;
            
            // Configurar física
            car.ellipsoid = new BABYLON.Vector3(0.9, 0.3, 2);
            car.ellipsoidOffset = new BABYLON.Vector3(0, 0.3, 0);
            
            // Habilitar colisiones del circuito
            scene.meshes.forEach(mesh => {
                if (mesh !== car && mesh.name !== "collider") {
                    mesh.checkCollisions = true;
                }
            });
            
            prevPosZ = car.position.z;
            debug.textContent = "¡Listo! Lamborghini en posición de salida";
            
        }, null, function (scene, message) {
            console.error("Error cargando lambo:", message);
            debug.textContent = "Error cargando Lamborghini";
        });
        
    }, null, function(s, msg){
        console.error("Error cargando circuito:", msg);
        debug.textContent = 'Error cargando spa.glb';
    });
}

function keepGround() {
    if (!car) return;
    
    const ray = new BABYLON.Ray(
        car.position.add(new BABYLON.Vector3(0, 5, 0)), 
        new BABYLON.Vector3(0, -1, 0), 
        10
    );
    
    const hit = scene.pickWithRay(ray, m => m !== car && m.name !== "collider");
    
    if (hit && hit.hit && hit.pickedPoint) {
        const targetY = hit.pickedPoint.y + 0.5;
        car.position.y = car.position.y + (targetY - car.position.y) * 0.1;
    }
}

const maxRealKmH = 200;
const speedFactor = maxRealKmH / maxSpeed;

// INICIAR
initGame();

engine.runRenderLoop(() => {
    if (!car || !camera) return;
    
    // ACTUALIZAR CÁMARA - FIJA DETRÁS DEL COCHE
    const cameraDistance = 8;
    const cameraHeight = 2;
    camera.position.x = car.position.x - Math.sin(car.rotation.y) * cameraDistance;
    camera.position.y = car.position.y + cameraHeight;
    camera.position.z = car.position.z - Math.cos(car.rotation.y) * cameraDistance;
    camera.setTarget(car.position);
    
    // Clima
    switch(weatherSelect.value){
        case 'sunny': scene.clearColor = new BABYLON.Color4(0.4, 0.7, 1, 1); break;
        case 'gray': scene.clearColor = new BABYLON.Color4(0.5, 0.5, 0.5, 1); break;
        case 'sunset': scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.2, 1); break;
    }
    scene.fogDensity = fogDensity;

    const dt = engine.getDeltaTime() / 1000;
    
    // Física
    if (moveForward && !moveBackward) {
        currentSpeed = Math.min(currentSpeed + accel * dt, maxSpeed);
    } else if (moveBackward && !moveForward) {
        if (currentSpeed > 0) {
            currentSpeed = Math.max(currentSpeed - brakeFriction * dt, 0);
        } else {
            currentSpeed = Math.max(currentSpeed - accel * dt, -maxReverse);
        }
    } else {
        if (currentSpeed > 0) {
            currentSpeed = Math.max(currentSpeed - airFriction * dt, 0);
        } else if (currentSpeed < 0) {
            currentSpeed = Math.min(currentSpeed + airFriction * dt, 0);
        }
    }
    
    updateJoystickState();
    
    // Rotación
    if (isJoystickActive && Math.abs(joystickRotation) > 0.1 && Math.abs(currentSpeed) >= minSpeedForSteering) {
        car.rotation.y += joystickRotation * rotationSpeed * dt * (currentSpeed / maxSpeed);
    }
    
    // Movimiento
    speedBar.style.width = (Math.min(Math.abs(currentSpeed) / maxSpeed, 1) * 100) + "%";
    speedBar.style.background = currentSpeed >= 0 ? "#0f0" : "#f00";
    
    if (Math.abs(currentSpeed) > 0.001) {
        const forward = new BABYLON.Vector3(
            Math.sin(car.rotation.y),
            0,
            Math.cos(car.rotation.y)
        );
        car.moveWithCollisions(forward.scale(currentSpeed * dt));
    }
    
    checkFinishLine();
    updateTimerDisplay();
    keepGround();
    
    debug.textContent = `Pos: X${car.position.x.toFixed(0)} Z${car.position.z.toFixed(0)} | Vel: ${(currentSpeed * speedFactor).toFixed(0)} km/h`;
    
    scene.render();
});

window.addEventListener('resize', () => engine.resize());
</script>
</body>
</html>